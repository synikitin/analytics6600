<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Data Analytics 6600</title>
    <link>https://synikitin.github.io/analytics6600/tags/lecture/index.xml</link>
    <description>Recent content on Data Analytics 6600</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Slava Nikitin</copyright>
    <atom:link href="/tags/lecture/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Program</title>
      <link>https://synikitin.github.io/analytics6600/post/program/</link>
      <pubDate>Mon, 06 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://synikitin.github.io/analytics6600/post/program/</guid>
      <description>&lt;!-- BLOGDOWN-BODY-BEFORE

/BLOGDOWN-BODY-BEFORE --&gt;

&lt;div id=&#34;pipe&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Pipe&lt;/h2&gt;
&lt;p&gt;The purpose behind pipes is to help simplify code that contains a chain of function calls by avoiding saving intermediate results. Here is data prep as an example:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;All tidyverse packages load the pipe by default, but &lt;strong&gt;magrittr&lt;/strong&gt; is the official package that contains it, and other operators as well.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(magrittr)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Data example is based on the second assignment:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;u.data &amp;lt;- read_tsv(
  &amp;quot;u.data&amp;quot;,
  col_names = c(&amp;quot;user_id&amp;quot;, &amp;quot;movie_id&amp;quot;, &amp;quot;rating&amp;quot;, &amp;quot;timestamp&amp;quot;)
)
u.item &amp;lt;- read_delim(
  &amp;quot;u.item&amp;quot;,
  &amp;quot;|&amp;quot;,
  col_names = c(
&amp;quot;movie_id&amp;quot;, &amp;quot;movie_title&amp;quot;, &amp;quot;release_date&amp;quot;,
&amp;quot;video_release_date&amp;quot;, &amp;quot;IMDb_URL&amp;quot;, &amp;quot;unknown&amp;quot;,
&amp;quot;Action&amp;quot;, &amp;quot;Adventure&amp;quot;, &amp;quot;Animation&amp;quot;, &amp;quot;Children&amp;#39;s&amp;quot;,
&amp;quot;Comedy&amp;quot;, &amp;quot;Crime&amp;quot;, &amp;quot;Documentary&amp;quot;, &amp;quot;Drama&amp;quot;, &amp;quot;Fantasy&amp;quot;,
&amp;quot;Film-Noir&amp;quot;, &amp;quot;Horror&amp;quot;, &amp;quot;Musical&amp;quot;, &amp;quot;Mystery&amp;quot;, &amp;quot;Romance&amp;quot;,
&amp;quot;Sci-Fi&amp;quot;, &amp;quot;Thriller&amp;quot;, &amp;quot;War&amp;quot;, &amp;quot;Western&amp;quot;
)
  )
u.user &amp;lt;- read_delim(
  &amp;quot;u.user&amp;quot;,
  &amp;quot;|&amp;quot;,
  col_names = c(&amp;quot;user_id&amp;quot;, &amp;quot;age&amp;quot;, &amp;quot;gender&amp;quot;, &amp;quot;occupation&amp;quot;, &amp;quot;zip_code&amp;quot;)
)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Save each intermediate result&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;df1 &amp;lt;- inner_join(u.data, u.user, &amp;quot;user_id&amp;quot;)
df2 &amp;lt;- inner_join(df1, u.item, &amp;quot;movie_id&amp;quot;)
df3 &amp;lt;- mutate(df2,
timestamp = as_datetime(timestamp), 
release_date = dmy(release_date)
  ) 
df4 &amp;lt;- select(df3, -video_release_date)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Overwrite each result&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;df &amp;lt;- inner_join(u.data, u.user, &amp;quot;user_id&amp;quot;)
df &amp;lt;- inner_join(df, u.item, &amp;quot;movie_id&amp;quot;)
df &amp;lt;- mutate(df,
timestamp = as_datetime(timestamp), 
release_date = dmy(release_date)
  ) 
df &amp;lt;- select(df, -video_release_date)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Nest each result&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;df &amp;lt;- select(
  mutate(
inner_join(
  inner_join(
    u.data,
    u.user,
    &amp;quot;user_id&amp;quot;
  ),
  u.item,
  &amp;quot;movie_id&amp;quot;
),
timestamp = as_datetime(timestamp), 
release_date = dmy(release_date)
  ),
  -video_release_date
)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Pipe each result&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;df &amp;lt;- inner_join(u.data, u.user, &amp;quot;user_id&amp;quot;) %&amp;gt;% 
  inner_join(u.item, &amp;quot;movie_id&amp;quot;) %&amp;gt;% 
  mutate(
timestamp = as_datetime(timestamp), 
release_date = dmy(release_date)
  ) %&amp;gt;% 
  select(-video_release_date)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;Pipes rewrite your code as if you used pattern in 3., that is assigning results into the same name over and passing it forward. When you see pipes you should think that the left-handside is becoming the first argument in a function call:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;x %&amp;gt;% f()&lt;/code&gt; is &lt;code&gt;f(x)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x %&amp;gt;% f(y)&lt;/code&gt; is &lt;code&gt;f(x, y)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;10 %&amp;gt;% rnorm(mean = 5, sd = 1)&lt;/code&gt; is &lt;code&gt;rnorm(10, mean = 5, sd = 1)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Pipes are great for several function calls that operate on the same or maybe a couple datasets and result in a single output. Long chains of function calls should be broken up, and when you are dealing with many datasets or many outputs, these cannot be or should not be combined as it may actually lead to more confusing code. It will also not work out of the box or at all with some special functions (book has examples).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Additional operator allowing side-effects, like printing structure to check intermediate results, in the middle of transformations&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;df &amp;lt;- inner_join(u.data, u.user, &amp;quot;user_id&amp;quot;) %T&amp;gt;%
  str %&amp;gt;% 
  inner_join(u.item, &amp;quot;movie_id&amp;quot;) %T&amp;gt;% 
  str %&amp;gt;% 
  mutate(
timestamp = as_datetime(timestamp), 
release_date = dmy(release_date)
  ) %T&amp;gt;% 
  str %&amp;gt;% 
  select(-video_release_date)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div id=&#34;functions&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Functions&lt;/h2&gt;
&lt;p&gt;One value of functions is to capture repeatedly written and used blocks of code, potentially with varying arguments, to enable reuse and code simplification. It is also about extending R to do things it cannot do out of the box or with any package. Lastly, it is a good way to wrap your complicated code into larger logical units and make it better communicable.&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;A function is an object that has several components: name, arguments, body, return value, environment. Here is a generic example of creating a new function&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;name &amp;lt;- function(argument) {
  var &amp;lt;- code(argument)
  return(var)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The generic example does not do anything, but here is a simple working example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;test_miss &amp;lt;- function(column) {
  missingness &amp;lt;- is.na(column)
  test &amp;lt;- any(missingness)
  return(test)
}&lt;/code&gt;&lt;/pre&gt;
This example takes a column, checks for missing values and returns TRUE if there are any missing values and FALSE if there are no missing values. Here are its components:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;test_miss&lt;/code&gt; is the name&lt;/li&gt;
&lt;li&gt;&lt;code&gt;col&lt;/code&gt; is the argument&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{missingness &amp;lt;- is.na(col); test &amp;lt;- any(missingness)}&lt;/code&gt; is the body, or where your code goes&lt;/li&gt;
&lt;li&gt;return value is &lt;code&gt;test&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;environmment is global; this is where you have been creating your data objects and what you see in the &lt;em&gt;environment&lt;/em&gt; tab in Rstudio. Do not worry about this component too much as it is a more advanced feature of R.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Name functions as any other object. Avoid reserved names
&lt;ul&gt;
&lt;li&gt;Start with letters, but can also contain numbers, as well as underscores &lt;code&gt;_&lt;/code&gt; and points &lt;code&gt;.&lt;/code&gt; to separate letters. &lt;code&gt;sum_var&lt;/code&gt;, &lt;code&gt;sum.var&lt;/code&gt;, &lt;code&gt;sum1&lt;/code&gt; are all valid names. You can add special symbols by placing the name of your function into backsticks ``.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Arguments are also named. These can have default values.
&lt;ul&gt;
&lt;li&gt;Same naming conventions&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Arguments can have default values by setting an argument equal to some value:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mean_na &amp;lt;- function(var, na = TRUE) {
  x &amp;lt;- mean(var, na.rm = na)
  return(x)
}&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Body contains all the computations you want to perform repeatedly. This may be quite complex by adding conditional statements
&lt;ul&gt;
&lt;li&gt;The braces &lt;code&gt;{}&lt;/code&gt; contain all your code as if it was in a script or Rmarkdown chunk&lt;/li&gt;
&lt;li&gt;You can make your function do different things depending on some conditions ``` check_categories &amp;lt;- function(var) { if (is.character(var) || is.factor(var)) { return(TRUE) } else { return(FALSE) } }&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;discretise &amp;lt;- function(var) { if (var &amp;lt; 0) { value &amp;lt;- “negative” return(value) } else if (var &amp;gt; 0) { value &amp;lt;- “positive” return(value) } else if (var == 0) { value &amp;lt;- “neutral” return(value) } } ```&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Return value may be required inside conditional statements, but otherwise is not needed because by default your funciton will return the last computed result in the body.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Environments are an advanced topic, but one thing that is important, is that functions can use variables not passed as arguments or created in the body, but rather created in the same place as the function. This is not recommended as it can make your functions unpredictable.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;Write all these functions and test them with example inputs:
&lt;ul&gt;
&lt;li&gt;Implement a function, with no arguments or code in the body&lt;/li&gt;
&lt;li&gt;Implement a function that has one argument and it just returns the argument value&lt;/li&gt;
&lt;li&gt;Implement a function that takes a vector of numbers and a single number to check whether a number is in the vector. It should return TRUE or FALSE&lt;/li&gt;
&lt;li&gt;Implement a function that takes a vector and a single value of the same type to find all missing values in a vector and replace them with a single value; use &lt;code&gt;if_else&lt;/code&gt; from &lt;em&gt;dplyr&lt;/em&gt; to help with this&lt;/li&gt;
&lt;li&gt;Implement a function that takes a vector and returns how many unique elements it has&lt;/li&gt;
&lt;li&gt;Implement a function that takes a vector and returns the shortest string if a vector is type character and smallest number if a vector is type double or integer. You can use function &lt;code&gt;which&lt;/code&gt; to find position of the minimum value, e.g. &lt;code&gt;which(3:1 == min(1:3))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Implement a function that calculates average squared difference between two vectors of numerical values&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div id=&#34;vectors&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Vectors&lt;/h2&gt;
&lt;p&gt;Data frames are a very useful data structure for data analysis, however when programming it may be an overkill or inadequate. This chapter introduces other ways of representing data in R. We concentrate on vectors - basic data structures in R out of which everything else is build, even data frames.&lt;/p&gt;
&lt;p&gt;Load &lt;code&gt;purrr&lt;/code&gt; library to get some of the functions.&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;Two basic types of vectors, atomic vectors that are usually just called vectors, and recursive vectors, usually called lists. There are two main differences: each element of an atomic vector has the same type and atomic vectors are flat, while recursive vectors can contain elements of different types and have hierarchical structure.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Vectors have types of logical, integer, double, complex, character, raw&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;c(TRUE, FALSE, NA) #logical
c(3L, 1L, 99L, NA) #integer
c(1.0, 0.008, NA, Inf, -Inf, NaN) #double
c(1+4i, 44+1i, NA, Inf, -Inf, NaN) #complex
c(&amp;quot;hello&amp;quot;, &amp;quot;there&amp;quot;, NA) #character
c(as.raw(0x00), as.raw(0xf4)) #raw&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;You can create vectors with the &lt;code&gt;c()&lt;/code&gt; function - which is mostly manual and shown above - or various functions that generate vectors with special values in them.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Logical vectors are typically created with logical comparisons or read from a file:&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;c(3L, 1L, 99L, NA) == 1L&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] FALSE  TRUE FALSE    NA&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;c(3L, 1L, 99L, NA) &amp;gt; 5L&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] FALSE FALSE  TRUE    NA&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Integer vectors are often read from a file, but are also used for subsetting other vectors, which requires pattern generation. If created by hand, numbers need &lt;em&gt;L&lt;/em&gt; as a suffix because the default numbers are double type:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;1&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;1L&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;1:3&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1 2 3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rep(1:3, times = 3)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1 2 3 1 2 3 1 2 3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rep(1:3, each = 3)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1 1 1 2 2 2 3 3 3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;seq(0, 12, by = 4)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1]  0  4  8 12&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;seq(0, 12, length.out = 3)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1]  0  6 12&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;seq_along(letters)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
## [24] 24 25 26&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;6&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Double vectors are often read from a file or may be generated with a random number generator:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rnorm(10, mean = 5, sd = 1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] 5.833045 3.732404 4.939552 5.880227 3.979677 3.589788 4.908387
##  [8] 3.458542 4.982259 3.566554&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;7&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;You will not see complex vectors unless you are doing pretty advanced math or physics.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Character vectors are often read from files, but also created, as you saw before with the Strings chapter:&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(stringr)
str_c(&amp;quot;file&amp;quot;, 1:10, &amp;quot;.csv&amp;quot;, sep = &amp;quot;&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;file1.csv&amp;quot;  &amp;quot;file2.csv&amp;quot;  &amp;quot;file3.csv&amp;quot;  &amp;quot;file4.csv&amp;quot;  &amp;quot;file5.csv&amp;quot; 
##  [6] &amp;quot;file6.csv&amp;quot;  &amp;quot;file7.csv&amp;quot;  &amp;quot;file8.csv&amp;quot;  &amp;quot;file9.csv&amp;quot;  &amp;quot;file10.csv&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;9&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;Raw vectors are also pretty rare and mostly used in more intricate programming.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Another way to create a vector is to coerce one into another.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;as.logical(c(0, 1, 1, 0))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] FALSE  TRUE  TRUE FALSE&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;as.integer(c(&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;3&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1 2 3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;as.double(c(&amp;quot;1.001&amp;quot;, &amp;quot;9.2842&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1.0010 9.2842&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;as.complex(c(&amp;quot;1.001&amp;quot;, &amp;quot;9.2842&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1.0010+0i 9.2842+0i&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;as.character(c(TRUE, FALSE))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;TRUE&amp;quot;  &amp;quot;FALSE&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;as.raw(0xf4)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] f4&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;10&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Coercision may be implicit by a function as a preparation for the downstream code&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;typeof(c(TRUE, 1L)) # these conversions follow the hierarchy from logical to character&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;integer&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;typeof(c(TRUE, 1))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;double&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;typeof(c(TRUE, &amp;quot;1&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;character&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sum(1:10 &amp;lt; 5)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 4&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;11&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;You can use &lt;code&gt;typeof&lt;/code&gt; or special test functions to determine types:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;is.logical(TRUE)
is.integer(1L)
is.double(1.0)
is.complex(1+1i)
is.character(&amp;quot;1&amp;quot;)
is.raw(as.raw(0x00))&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Another useful property of vectors is &lt;code&gt;length&lt;/code&gt;:&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x &amp;lt;- c(TRUE, FALSE, NA)
length(x)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 3&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;13&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Working with multiple vectors of different length will invoke recycling which is repeating the elements of the shorter vector to match the length of the longer vector:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;1:3 + 3 == 1:3 + c(3, 3, 3)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE TRUE TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;14&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;It may be useful to name vectors&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;c(a = 1, b = 2, c = 3)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## a b c 
## 1 2 3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;setNames(1:3, c(&amp;quot;one&amp;quot;, &amp;quot;two&amp;quot;, &amp;quot;three&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   one   two three 
##     1     2     3&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;15&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;It is often needed to pull out specific elements of vectors. For this we use &lt;code&gt;[]&lt;/code&gt; syntax, with either position or name:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;c(1, 2, 3)[3]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;c(&amp;quot;one&amp;quot;, &amp;quot;two&amp;quot;, &amp;quot;three&amp;quot;)[2:3]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;two&amp;quot;   &amp;quot;three&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;c(&amp;quot;one&amp;quot;, &amp;quot;two&amp;quot;, &amp;quot;three&amp;quot;)[-1]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;two&amp;quot;   &amp;quot;three&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;c(&amp;quot;one&amp;quot;, &amp;quot;two&amp;quot;, &amp;quot;three&amp;quot;, &amp;quot;one&amp;quot;, &amp;quot;two&amp;quot;, &amp;quot;three&amp;quot;)[c(1, 3, 5)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;one&amp;quot;   &amp;quot;three&amp;quot; &amp;quot;two&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;c(1, 2, 3, 4)[-(2:3)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1 4&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;letters[TRUE]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;a&amp;quot; &amp;quot;b&amp;quot; &amp;quot;c&amp;quot; &amp;quot;d&amp;quot; &amp;quot;e&amp;quot; &amp;quot;f&amp;quot; &amp;quot;g&amp;quot; &amp;quot;h&amp;quot; &amp;quot;i&amp;quot; &amp;quot;j&amp;quot; &amp;quot;k&amp;quot; &amp;quot;l&amp;quot; &amp;quot;m&amp;quot; &amp;quot;n&amp;quot; &amp;quot;o&amp;quot; &amp;quot;p&amp;quot; &amp;quot;q&amp;quot;
## [18] &amp;quot;r&amp;quot; &amp;quot;s&amp;quot; &amp;quot;t&amp;quot; &amp;quot;u&amp;quot; &amp;quot;v&amp;quot; &amp;quot;w&amp;quot; &amp;quot;x&amp;quot; &amp;quot;y&amp;quot; &amp;quot;z&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;letters[c(TRUE, FALSE)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;a&amp;quot; &amp;quot;c&amp;quot; &amp;quot;e&amp;quot; &amp;quot;g&amp;quot; &amp;quot;i&amp;quot; &amp;quot;k&amp;quot; &amp;quot;m&amp;quot; &amp;quot;o&amp;quot; &amp;quot;q&amp;quot; &amp;quot;s&amp;quot; &amp;quot;u&amp;quot; &amp;quot;w&amp;quot; &amp;quot;y&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;1[0]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## numeric(0)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x &amp;lt;- c(one = 1, two = 2, three = 3)
x[c(&amp;quot;one&amp;quot;, &amp;quot;two&amp;quot;)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## one two 
##   1   2&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;16&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Lists share many features of atomic vectors, like naming, but are more complex than atomic vector because they can contain mixed types and hierarchies. To create a list you use&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;list(1, 2, 3)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [[1]]
## [1] 1
## 
## [[2]]
## [1] 2
## 
## [[3]]
## [1] 3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;list(TRUE, 1L, 1, 1+1i, &amp;quot;one&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [[1]]
## [1] TRUE
## 
## [[2]]
## [1] 1
## 
## [[3]]
## [1] 1
## 
## [[4]]
## [1] 1+1i
## 
## [[5]]
## [1] &amp;quot;one&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;list(one = 1, two = 2, three = 3)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $one
## [1] 1
## 
## $two
## [1] 2
## 
## $three
## [1] 3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;list(one = 1, two = list(three = 3, four = 4))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $one
## [1] 1
## 
## $two
## $two$three
## [1] 3
## 
## $two$four
## [1] 4&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str(list(one = 1, two = list(three = 3, four = 4)))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## List of 2
##  $ one: num 1
##  $ two:List of 2
##   ..$ three: num 3
##   ..$ four : num 4&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;17&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Lists also have the basic properties of vectors:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;typeof(list(1))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;list&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;length(list(1, 2, 3, 4))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 4&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;18&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;You can also subset lists to pull various elements, either by position or name:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;list(1, 2, 3)[1:2]
list(1, 2, list(3, 4))[[3]]
x &amp;lt;- list(one = 1, two = 2)
x[&amp;quot;one&amp;quot;]
x$one&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Vectors and lists can be enhanced with &lt;code&gt;attributes&lt;/code&gt;. The most important ones are &lt;em&gt;names&lt;/em&gt;, &lt;em&gt;dims&lt;/em&gt; and &lt;em&gt;class&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;attributes(mtcars) #to check&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $names
##  [1] &amp;quot;mpg&amp;quot;  &amp;quot;cyl&amp;quot;  &amp;quot;disp&amp;quot; &amp;quot;hp&amp;quot;   &amp;quot;drat&amp;quot; &amp;quot;wt&amp;quot;   &amp;quot;qsec&amp;quot; &amp;quot;vs&amp;quot;   &amp;quot;am&amp;quot;   &amp;quot;gear&amp;quot;
## [11] &amp;quot;carb&amp;quot;
## 
## $row.names
##  [1] &amp;quot;Mazda RX4&amp;quot;           &amp;quot;Mazda RX4 Wag&amp;quot;       &amp;quot;Datsun 710&amp;quot;         
##  [4] &amp;quot;Hornet 4 Drive&amp;quot;      &amp;quot;Hornet Sportabout&amp;quot;   &amp;quot;Valiant&amp;quot;            
##  [7] &amp;quot;Duster 360&amp;quot;          &amp;quot;Merc 240D&amp;quot;           &amp;quot;Merc 230&amp;quot;           
## [10] &amp;quot;Merc 280&amp;quot;            &amp;quot;Merc 280C&amp;quot;           &amp;quot;Merc 450SE&amp;quot;         
## [13] &amp;quot;Merc 450SL&amp;quot;          &amp;quot;Merc 450SLC&amp;quot;         &amp;quot;Cadillac Fleetwood&amp;quot; 
## [16] &amp;quot;Lincoln Continental&amp;quot; &amp;quot;Chrysler Imperial&amp;quot;   &amp;quot;Fiat 128&amp;quot;           
## [19] &amp;quot;Honda Civic&amp;quot;         &amp;quot;Toyota Corolla&amp;quot;      &amp;quot;Toyota Corona&amp;quot;      
## [22] &amp;quot;Dodge Challenger&amp;quot;    &amp;quot;AMC Javelin&amp;quot;         &amp;quot;Camaro Z28&amp;quot;         
## [25] &amp;quot;Pontiac Firebird&amp;quot;    &amp;quot;Fiat X1-9&amp;quot;           &amp;quot;Porsche 914-2&amp;quot;      
## [28] &amp;quot;Lotus Europa&amp;quot;        &amp;quot;Ford Pantera L&amp;quot;      &amp;quot;Ferrari Dino&amp;quot;       
## [31] &amp;quot;Maserati Bora&amp;quot;       &amp;quot;Volvo 142E&amp;quot;         
## 
## $class
## [1] &amp;quot;data.frame&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;attr(mtcars, &amp;quot;something&amp;quot;) &amp;lt;- 1:3 #to set&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;20&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Several data structures you have seen are actually build out of vectors and lists combined with special attributes:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;typeof(lubridate::as_date(Sys.time()))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;double&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;attributes(lubridate::as_date(Sys.time()))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $class
## [1] &amp;quot;Date&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;iteration&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Iteration&lt;/h2&gt;
&lt;/div&gt;


&lt;!-- BLOGDOWN-HEAD




/BLOGDOWN-HEAD --&gt;
</description>
    </item>
    
    <item>
      <title>Wrangle - Part II</title>
      <link>https://synikitin.github.io/analytics6600/post/wrangle2/</link>
      <pubDate>Mon, 20 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://synikitin.github.io/analytics6600/post/wrangle2/</guid>
      <description>&lt;!-- BLOGDOWN-BODY-BEFORE

/BLOGDOWN-BODY-BEFORE --&gt;

&lt;div id=&#34;strings&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Strings&lt;/h2&gt;
&lt;p&gt;Package: &lt;code&gt;library(stringr)&lt;/code&gt;&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;Creation:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x &amp;lt;- &amp;quot;Richard Stallman doesn&amp;#39;t mind if you read his mail as long as you don&amp;#39;t delete it before he reads it. &amp;quot;
y &amp;lt;- &amp;#39;Richard Stallman met Chuck Norris once. Chuck tried a roundhouse, but Richard bashed him 
in the skull.&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Try creating this string&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;#39;Richard Stallman&amp;#39;s beard trimmings can cure cancer. Too bad he never shaves.&amp;#39;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Escaping quotes to have quotes inside quotes&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;#39;Richard Stallman\&amp;#39;s beard trimmings can cure cancer. Too bad he never shaves.&amp;#39;
&amp;quot;Richard Stallman gets \&amp;quot;9 bits\&amp;quot; to the byte.&amp;quot;  &lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Use &lt;code&gt;writeLines&lt;/code&gt; as opposed to &lt;code&gt;print&lt;/code&gt; to show the actual string&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;writeLines(&amp;quot;Richard Stallman gets \&amp;quot;9 bits\&amp;quot; to the byte.&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;Special strings signifying space:
&lt;ul&gt;
&lt;li&gt;“\n” newline&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;“\r” carriage return&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;“\t” tab&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Create a vector of strings:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;c(&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;d&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Number of characters (length):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;str_length(
 c(&amp;quot;Richard Stallman can solve the halting problem... in polynomial time.&amp;quot;, NA)
)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Combine strings:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;str_c(&amp;quot;hello&amp;quot;, c(&amp;quot;there&amp;quot;, &amp;quot;here&amp;quot;), sep = &amp;quot; &amp;quot;)
str_c(&amp;quot;hello&amp;quot;, c(&amp;quot;there&amp;quot;, &amp;quot;here&amp;quot;, &amp;quot;&amp;quot;), sep = &amp;quot; &amp;quot;, collapse = &amp;quot; &amp;quot;)
x &amp;lt;- &amp;quot;Class&amp;quot;
str_c(
  x,
  &amp;quot;is ...&amp;quot;,
  if (wday(Sys.time(), label = TRUE) == &amp;quot;Mon&amp;quot;) &amp;quot;on&amp;quot; else &amp;quot;off&amp;quot;,
  sep = &amp;quot; &amp;quot;
)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Sub-strings:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;str_sub(&amp;quot;Richard Stallman did not write GNU Emacs, he simply read the source code from /dev/null.&amp;quot;, start = 1, end = 7)
str_sub(&amp;quot;Richard Stallman did not write GNU Emacs, he simply read the source code from /dev/null.&amp;quot;, start = -6, end = -1)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;String case:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;str_to_lower(&amp;quot;LARGE LETTERS&amp;quot;)
str_to_upper(&amp;quot;SMALL LETTERS&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;String sort:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;str_sort(c(&amp;quot;Monday&amp;quot;, &amp;quot;Tuesday&amp;quot;, &amp;quot;Saturday&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Exercise: Fix the following strings if needed, lower their case, then combine them with newline character to show one quote per line, and finally get the length of the full string.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;#39;Richard Stallman doesn&amp;#39;t need sudo. I will make him a sandwich anyway.&amp;#39;
&amp;quot;Richard Stallman&amp;#39;s beard is made of parentheses.&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Regular expression:&lt;br /&gt;
I often refer to this &lt;a href=&#34;https://www.cheatography.com/davechild/cheat-sheets/regular-expressions/&#34;&gt;cheatsheet&lt;/a&gt; to remind myself of syntax. I will show only simple examples as it is better learned piece by piece as needed.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;a-b 0-9 Alpha-numerical characters&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x &amp;lt;- &amp;quot;zip code 60099&amp;quot;
str_extract(string = x, pattern = &amp;quot;zip code&amp;quot;)
str_detect(string = x, pattern = &amp;quot;60099&amp;quot;)
str_replace(string = x, pattern = &amp;quot;60099&amp;quot;, replacement = &amp;quot;60000&amp;quot;)
str_split(string = x, pattern = &amp;quot; &amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;!-) Special symbols may need escaping if they are regex syntax&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x &amp;lt;- &amp;quot;zip code @ (#60099)&amp;quot;
str_extract(string = x, pattern = &amp;quot;\\(&amp;quot;)
str_detect(string = x, pattern = &amp;quot;#&amp;quot;)
str_replace(string = x, pattern = &amp;quot;@&amp;quot;, replacement = &amp;quot;&amp;quot;)
str_split(string = x, pattern = &amp;quot; &amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;. One of any symbols&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x &amp;lt;- &amp;quot;zip code @ (#60099).&amp;quot;
str_extract(string = x, pattern = &amp;quot;z.p&amp;quot;)
str_detect(string = x, pattern = &amp;quot;co.e&amp;quot;)
str_replace_all(string = x, pattern = &amp;quot;\\.&amp;quot;, replacement = &amp;quot;!&amp;quot;)
str_split(string = x, pattern = &amp;quot;.&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;Special symbols
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;\\d&lt;/code&gt; digits 0 - 9&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\\s&lt;/code&gt; spaces like \n&lt;/li&gt;
&lt;li&gt;[a1@] any group of symbols&lt;/li&gt;
&lt;li&gt;&lt;p&gt;[^a1@] ^ makes it NOT this group of symbols&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x &amp;lt;- &amp;quot;zip code @ (#60099).\n&amp;quot;
str_replace_all(string = x, pattern = &amp;quot;\\s&amp;quot;, replacement = &amp;quot; &amp;quot;)
str_detect(string = x, pattern = &amp;quot;[@#]&amp;quot;)
str_extract_all(string = x, pattern = &amp;quot;[^@#()]&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Anchors
&lt;ul&gt;
&lt;li&gt;^ front&lt;/li&gt;
&lt;li&gt;&lt;p&gt;$ back&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x &amp;lt;- &amp;quot;truth is truth&amp;quot;
str_replace_all(string = x, pattern = &amp;quot;^truth&amp;quot;, replacement = &amp;quot;lie&amp;quot;)
str_replace_all(string = x, pattern = &amp;quot;truth$&amp;quot;, replacement = &amp;quot;lie&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;| is a logical OR operator for multiple patterns&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x &amp;lt;- &amp;quot;zip code @ (#60099).\n&amp;quot;
str_replace_all(string = x, pattern = &amp;quot;\\d|[@#()]&amp;quot;, replacement = &amp;quot;&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;Quantifiers
&lt;ul&gt;
&lt;li&gt;? (0 or 1 times)&lt;/li&gt;
&lt;li&gt;+ (1 or more)&lt;/li&gt;
&lt;li&gt;&lt;p&gt;* (0 or more)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x &amp;lt;- &amp;quot;groowthh&amp;quot;
str_extract_all(string = x, pattern = &amp;quot;o+&amp;quot;)
str_detect(string = x, pattern = &amp;quot;o+w?th*&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;categorical-data-with-factor-type&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Categorical Data with Factor Type&lt;/h2&gt;
&lt;p&gt;Package: &lt;code&gt;library(forcats)&lt;/code&gt;&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;Create factor to represent a categorical variable&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x &amp;lt;- c(&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;)
factor(x, levels = c(&amp;quot;b&amp;quot;, &amp;quot;a&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Control levels (categories)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;factor(c(&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;), levels = c(&amp;quot;b&amp;quot;, &amp;quot;a&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Reorder levels using a numerical variable&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(dplyr)
x &amp;lt;- tibble(f = factor(letters[1:4]),
        n = c(3, 1, 2, 4))
y &amp;lt;- mutate(x, f = fct_reorder(f, n, mean))&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div id=&#34;date-datetime-time&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Date, Datetime, Time&lt;/h2&gt;
&lt;p&gt;Package: &lt;code&gt;library(lubridate)&lt;/code&gt;&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;Timestamps to datetimes&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(lubridate)
timestamp &amp;lt;- Sys.time() # creates an example timestamp
timestamp # shows timestamp
as.integer(timestamp) # shows underlying representation of timestamp
x &amp;lt;- as.integer(timestamp) # convert timestamp to integer
as_datetime(x) # convert integer to timestamp&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Range of datetimes&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Sys.time() + 1:10
range(Sys.time() + 1:10)
min(Sys.time() + 1:10)
max(Sys.time() + 1:10)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Extract pieces like days, weeks, years, hours, seconds…&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x &amp;lt;- Sys.time()
year(x)
month(x)
month(x, label = TRUE)
wday(x)
wday(x, label = TRUE)
hour(x)
minute(x)
second(x)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Strings to dates&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ymd(&amp;quot;2017-02-20&amp;quot;)
dmy(&amp;quot;01-01-1910&amp;quot;)
ymd(&amp;quot;2017-Feb-20&amp;quot;)
dmy_hms(&amp;quot;01-01-1910 23:44:56&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;


&lt;!-- BLOGDOWN-HEAD




/BLOGDOWN-HEAD --&gt;
</description>
    </item>
    
    <item>
      <title>Wrangle - Part I</title>
      <link>https://synikitin.github.io/analytics6600/post/wrangle/</link>
      <pubDate>Mon, 13 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://synikitin.github.io/analytics6600/post/wrangle/</guid>
      <description>&lt;!-- BLOGDOWN-BODY-BEFORE

/BLOGDOWN-BODY-BEFORE --&gt;

&lt;div id=&#34;basic-concepts&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Basic Concepts&lt;/h1&gt;
&lt;div id=&#34;material&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Material&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;tibble(x = 1:3)&lt;/code&gt; local in R&lt;/li&gt;
&lt;li&gt;&lt;code&gt;data()&lt;/code&gt; - local in R&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;%22/Users/snikitin/Documents/training/class/analytics6600/static/data/movies.csv%22&#34;&gt;&lt;/a&gt; - local on disc&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;%22https://synikitin.github.io/analytics6600/data/movies.csv%22&#34;&gt;&lt;/a&gt; - remote on disk, direct download&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;%22https://www.quandl.com/tools/api%22&#34;&gt;&lt;/a&gt; - remote on disc, api&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;machinery&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Machinery&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;computer&lt;/li&gt;
&lt;li&gt;integrated development environment (IDE)&lt;/li&gt;
&lt;li&gt;programming language&lt;/li&gt;
&lt;li&gt;file formats&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;product&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Product&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;data&lt;/li&gt;
&lt;li&gt;clean data&lt;/li&gt;
&lt;li&gt;visualization&lt;/li&gt;
&lt;li&gt;statistical model&lt;/li&gt;
&lt;li&gt;report&lt;/li&gt;
&lt;li&gt;web application&lt;/li&gt;
&lt;li&gt;optimized algorithm&lt;/li&gt;
&lt;li&gt;package&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;task&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Task&lt;/h1&gt;
&lt;div id=&#34;io&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;IO&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;library(readr)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;library(tibble)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;tidy&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Tidy&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;library(tidyr)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;transform&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Transform&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;library(dplyr)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;visualization&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Visualization&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;library(ggplot2)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;programming&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Programming&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;library(magrittr)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;learning-new-packages-and-functions&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Learning new packages and functions&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;CRAN&lt;/li&gt;
&lt;li&gt;&lt;code&gt;help(package = &amp;quot;readr&amp;quot;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;purpose&lt;/li&gt;
&lt;li&gt;available arguments&lt;/li&gt;
&lt;li&gt;example code, sometimes &lt;code&gt;demo(package = &amp;quot;stats&amp;quot;)&lt;/code&gt;, &lt;code&gt;example(&amp;quot;summarise&amp;quot;, package = &amp;quot;dplyr&amp;quot;)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;tibbles&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Tibbles&lt;/h1&gt;
&lt;div id=&#34;creating&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Creating&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;tibble&lt;/code&gt; tibble( population = c(783744, 923972, 823972, 789374), city = c(“chicago”, “columbus”, “boston”, “cleveland”) )&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;tribble&lt;/code&gt; tribble( ~x, ~y, 1, “2”, 3, 4 )&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;printing&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Printing&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;print(df, n, width)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;str&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;View&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;subsetting&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Subsetting&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;df[[&amp;quot;a&amp;quot;]]&lt;/code&gt;, &lt;code&gt;df[[1]]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;df$a&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;data-import&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Data Import&lt;/h1&gt;
&lt;div id=&#34;read_csv&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;read_csv&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;read_csv( 
  &amp;quot;Some random text here
  a,b,c
  1,2,! #This is a comment. ! is a missing value.
  4,5,6&amp;quot;,
  skip = 2,
  na = &amp;quot;!&amp;quot;,
  comment = &amp;quot;#&amp;quot;,
  n_max = 2,
  col_names = c(&amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;, &amp;quot;z&amp;quot;),
  col_types = cols(x = col_integer(),
                   y = col_double(),
                   z = col_character())
)             &lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;arguments&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;arguments&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;skip&lt;/li&gt;
&lt;li&gt;comment&lt;/li&gt;
&lt;li&gt;col_names&lt;/li&gt;
&lt;li&gt;na&lt;/li&gt;
&lt;li&gt;n_max&lt;/li&gt;
&lt;li&gt;locale&lt;/li&gt;
&lt;li&gt;col_types (logical, numbers, text, date, time, datetime)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;write_csv-write_excel_csv-write_rds&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;write_csv, write_excel_csv, write_rds&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;similar arguments&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;other-packages&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;other packages&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;haven&lt;/li&gt;
&lt;li&gt;readxl&lt;/li&gt;
&lt;li&gt;DBI&lt;/li&gt;
&lt;li&gt;jsonlite&lt;/li&gt;
&lt;li&gt;&lt;p&gt;xml2&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Lets practice &lt;code&gt;read_csv&lt;/code&gt; with the following data:&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;x &amp;lt;- &amp;quot;Confidential Data - Email abc@gmail.com for Permission
    $earnings,Months in 2017,store
    14343.43,January,! *Note: missing values marked with !
    34322.33,February,6343\n&amp;quot;
    
writeChar(  
  x,
  &amp;quot;readr_example.csv&amp;quot;,
  176
)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;tidying-data&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Tidying Data&lt;/h1&gt;
&lt;div id=&#34;structure&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Structure&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;columns&lt;/li&gt;
&lt;li&gt;rows&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;semantics&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Semantics&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;unit&lt;/li&gt;
&lt;li&gt;variable&lt;/li&gt;
&lt;li&gt;value&lt;/li&gt;
&lt;li&gt;observation&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;messy-data&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Messy data&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Column headers are values, not variable names. This is messy&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;a &amp;lt;- tribble(
  ~region, ~`$0 - $100k`, ~`$100k - $1,000k`, ~`$1,000k - $10,000k`,
  &amp;quot;midwest&amp;quot;, 152, 78, 5,
  &amp;quot;west&amp;quot;, 190, 130, 10
  )
a&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 2 × 4
##    region `$0 - $100k` `$100k - $1,000k` `$1,000k - $10,000k`
##     &amp;lt;chr&amp;gt;        &amp;lt;dbl&amp;gt;             &amp;lt;dbl&amp;gt;                &amp;lt;dbl&amp;gt;
## 1 midwest          152                78                    5
## 2    west          190               130                   10&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and this is tidy by turning headers into a variable.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;gather(data = a, key = income, value = count, 2:4)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 × 3
##    region             income count
##     &amp;lt;chr&amp;gt;              &amp;lt;chr&amp;gt; &amp;lt;dbl&amp;gt;
## 1 midwest         $0 - $100k   152
## 2    west         $0 - $100k   190
## 3 midwest    $100k - $1,000k    78
## 4    west    $100k - $1,000k   130
## 5 midwest $1,000k - $10,000k     5
## 6    west $1,000k - $10,000k    10&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Multiple variables are stored in one column. This is messy&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;b &amp;lt;- tribble(
  ~`region-income`, ~count,
  &amp;quot;midwest, $0 - 100k&amp;quot;, 152,
  &amp;quot;west, $0 - 100k&amp;quot;, 190,
  &amp;quot;midwest, $100k - 1,000k&amp;quot;, 78,
  &amp;quot;west, $100k - 1,000k&amp;quot;, 130
)
b&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 4 × 2
##           `region-income` count
##                     &amp;lt;chr&amp;gt; &amp;lt;dbl&amp;gt;
## 1      midwest, $0 - 100k   152
## 2         west, $0 - 100k   190
## 3 midwest, $100k - 1,000k    78
## 4    west, $100k - 1,000k   130&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and this is tidy by splitting a variable into two variables.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;separate(data = b, col = `region-income`,
         into = c(&amp;quot;region&amp;quot;, &amp;quot;income&amp;quot;), sep = &amp;quot;, &amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 4 × 3
##    region         income count
## *   &amp;lt;chr&amp;gt;          &amp;lt;chr&amp;gt; &amp;lt;dbl&amp;gt;
## 1 midwest      $0 - 100k   152
## 2    west      $0 - 100k   190
## 3 midwest $100k - 1,000k    78
## 4    west $100k - 1,000k   130&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Variables are stored in rows. This is messy&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;d &amp;lt;- tribble(
  ~region, ~income, ~statistic,
  &amp;quot;midwest&amp;quot;, 193478374, &amp;quot;annual_max&amp;quot;,
  &amp;quot;midwest&amp;quot;, 878743, &amp;quot;annual_min&amp;quot;,
  &amp;quot;west&amp;quot;, 29743443, &amp;quot;annual_max&amp;quot;,
  &amp;quot;west&amp;quot;, 19984028, &amp;quot;annual_min&amp;quot;
)
d&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 4 × 3
##    region    income  statistic
##     &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt;      &amp;lt;chr&amp;gt;
## 1 midwest 193478374 annual_max
## 2 midwest    878743 annual_min
## 3    west  29743443 annual_max
## 4    west  19984028 annual_min&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and this is tidy by turning a variable into column headers.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;spread(data = d, key = statistic, value = income)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 2 × 3
##    region annual_max annual_min
## *   &amp;lt;chr&amp;gt;      &amp;lt;dbl&amp;gt;      &amp;lt;dbl&amp;gt;
## 1 midwest  193478374     878743
## 2    west   29743443   19984028&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Multiple types of observational units are stored in the same table, in this case two separate time scales. This is messy&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;e &amp;lt;- tribble(
  ~region, ~annual_max, ~annual_min, ~monthly_avg, ~month,
  &amp;quot;midwest&amp;quot;, 193478374, 878743, 193947931, &amp;quot;January&amp;quot;,
  &amp;quot;midwest&amp;quot;, 193478374, 878743, 153394881, &amp;quot;February&amp;quot;
)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and this is tidy by removing annual scale variables&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;select(e, -annual_max, -annual_min)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 2 × 3
##    region monthly_avg    month
##     &amp;lt;chr&amp;gt;       &amp;lt;dbl&amp;gt;    &amp;lt;chr&amp;gt;
## 1 midwest   193947931  January
## 2 midwest   153394881 February&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or this is tidy by removing monthly scale variables.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;select(e, -monthly_avg, -month) %&amp;gt;% 
  distinct&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1 × 3
##    region annual_max annual_min
##     &amp;lt;chr&amp;gt;      &amp;lt;dbl&amp;gt;      &amp;lt;dbl&amp;gt;
## 1 midwest  193478374     878743&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;A single observational unit is stored in multiple tables. This is messy&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;f &amp;lt;- tribble(
  ~region, ~income, ~statistic,
  &amp;quot;midwest&amp;quot;, 193478374, &amp;quot;annual_max&amp;quot;,
  &amp;quot;midwest&amp;quot;, 878743, &amp;quot;annual_min&amp;quot;
)
g &amp;lt;- tribble(
  ~region, ~income, ~statistic,
  &amp;quot;west&amp;quot;, 29743443, &amp;quot;annual_max&amp;quot;,
  &amp;quot;west&amp;quot;, 19984028, &amp;quot;annual_min&amp;quot;
)
f&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 2 × 3
##    region    income  statistic
##     &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt;      &amp;lt;chr&amp;gt;
## 1 midwest 193478374 annual_max
## 2 midwest    878743 annual_min&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;g&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 2 × 3
##   region   income  statistic
##    &amp;lt;chr&amp;gt;    &amp;lt;dbl&amp;gt;      &amp;lt;chr&amp;gt;
## 1   west 29743443 annual_max
## 2   west 19984028 annual_min&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and this is tidy by combining them into a single data frame.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;bind_rows(f, g)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 4 × 3
##    region    income  statistic
##     &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt;      &amp;lt;chr&amp;gt;
## 1 midwest 193478374 annual_max
## 2 midwest    878743 annual_min
## 3    west  29743443 annual_max
## 4    west  19984028 annual_min&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Tidy the following dataset. It consists of a history of quarterly earnings per share of Johnson and Johnson.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;df &amp;lt;- matrix(JohnsonJohnson, byrow = TRUE, ncol = 4) %&amp;gt;% 
  as_tibble() %&amp;gt;%
  rename(quarter1 = V1, quarter2 = V2, quarter3 = V3, quarter4 = V4) %&amp;gt;% 
  mutate(year = 1960:1980, stockinfo = &amp;quot;JNJ-NYSE&amp;quot;)
df&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 21 × 6
##    quarter1 quarter2 quarter3 quarter4  year stockinfo
##       &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt;     &amp;lt;chr&amp;gt;
## 1      0.71     0.63     0.85     0.44  1960  JNJ-NYSE
## 2      0.61     0.69     0.92     0.55  1961  JNJ-NYSE
## 3      0.72     0.77     0.92     0.60  1962  JNJ-NYSE
## 4      0.83     0.80     1.00     0.77  1963  JNJ-NYSE
## 5      0.92     1.00     1.24     1.00  1964  JNJ-NYSE
## 6      1.16     1.30     1.45     1.25  1965  JNJ-NYSE
## 7      1.26     1.38     1.86     1.56  1966  JNJ-NYSE
## 8      1.53     1.59     1.83     1.86  1967  JNJ-NYSE
## 9      1.53     2.07     2.34     2.25  1968  JNJ-NYSE
## 10     2.16     2.43     2.70     2.25  1969  JNJ-NYSE
## # ... with 11 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;relational-data&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Relational data&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;tables and keys (primary, foreign, surrogate); key in the following data sets&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;stocks &amp;lt;- tibble(earnings = c(800, 150, 240, 65),
                 volume = c(1599500, 30531626, 4276880, 25187460),
                 symbol = c(&amp;quot;GOOG&amp;quot;, &amp;quot;APPL&amp;quot;, &amp;quot;GS&amp;quot;, &amp;quot;MSFT&amp;quot;))
stocks&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 4 × 3
##   earnings   volume symbol
##      &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;  &amp;lt;chr&amp;gt;
## 1      800  1599500   GOOG
## 2      150 30531626   APPL
## 3      240  4276880     GS
## 4       65 25187460   MSFT&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;stocks2 &amp;lt;- tibble(earnings = c(800, 15),
                  volume = c(1599500, 13210000),
                  symbol = c(&amp;quot;GOOG&amp;quot;, &amp;quot;HBAN&amp;quot;))

symbols &amp;lt;- tibble(symbol = c(&amp;quot;GOOG&amp;quot;, &amp;quot;APPL&amp;quot;, &amp;quot;GS&amp;quot;, &amp;quot;HBAN&amp;quot;),
                  exchange = c(&amp;quot;NASDAQ&amp;quot;, &amp;quot;NASDAQ&amp;quot;, &amp;quot;NYSE&amp;quot;, &amp;quot;NASDAQ&amp;quot;))
symbols&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 4 × 2
##   symbol exchange
##    &amp;lt;chr&amp;gt;    &amp;lt;chr&amp;gt;
## 1   GOOG   NASDAQ
## 2   APPL   NASDAQ
## 3     GS     NYSE
## 4   HBAN   NASDAQ&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;left, right, outer join (mutating)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;inner_join(x = stocks, y = symbols, by = &amp;quot;symbol&amp;quot;)
left_join(x = stocks, y = symbols, by = &amp;quot;symbol&amp;quot;)
right_join(x = stocks, y = symbols, by = &amp;quot;symbol&amp;quot;)
full_join(x = stocks, y = symbols, by = &amp;quot;symbol&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;semi, anti join (filtering)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;semi_join(x = stocks, y = symbols, by = &amp;quot;symbol&amp;quot;)
anti_join(x = stocks, y = symbols, by = &amp;quot;symbol&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;intersect, union, setdiff&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;union(x = stocks, y = stocks2)
intersect(x = stocks, y = stocks2)
setdiff(x = stocks, y = stocks2)
setdiff(x = stocks2, y = stocks)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Identify primary and foreign keys in all datasets&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;set.seed(349834)

calls &amp;lt;- tibble(
  company = &amp;quot;schevchenko steele&amp;quot;, #rep(companies, each = 12)
  number = rbinom(5, 30, .3),
  month = month.name[1:5] #rep(month.name, 10)
)
sales &amp;lt;- tibble(
  company = &amp;quot;schevchenko steele&amp;quot;,
  amount = rgamma(10, 1e4, 1 / 1e4),
  month = month.name[-c(1, 9)]
)
orders &amp;lt;- tibble(
  company = &amp;quot;schevchenko steele&amp;quot;,
  fullfilment = rbeta(10, 4, 8),
  month = month.name[-c(1, 9)]
) &lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Join calls and sales for only matching months&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Enrich calls with whatever sales data there is&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Enrich sales with whatever calls data there is&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Join calls and sales for all months&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Obtain sales data for which you have calls&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Obtain orders data for which you have no calls&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Join all datasets into a single data frame with all months&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;


&lt;!-- BLOGDOWN-HEAD




/BLOGDOWN-HEAD --&gt;
</description>
    </item>
    
  </channel>
</rss>
