<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Data Analytics 6600</title>
    <link>/tags/lecture/index.xml</link>
    <description>Recent content on Data Analytics 6600</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2018 Slava Nikitin</copyright>
    <atom:link href="/tags/lecture/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Case Study 1</title>
      <link>/post/case1_abstracts/</link>
      <pubDate>Mon, 22 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/case1_abstracts/</guid>
      <description>&lt;!-- BLOGDOWN-BODY-BEFORE

/BLOGDOWN-BODY-BEFORE --&gt;

&lt;div id=&#34;conference-proceedings-analysis&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Conference Proceedings Analysis&lt;/h2&gt;
&lt;div id=&#34;project&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Project&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Background&lt;/strong&gt;&lt;br /&gt;
A health care company XYZ LLC hosts conferences on novel variants of cancer and technologies meant to detect it early. Scientists in charge of it are responsible for preparing a summary presentation of past and present research.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Objectives&lt;/strong&gt;&lt;br /&gt;
Understand origins of authors, co-author network, novel variants of cancer, clusters of abstracts based on similar topics, trends across the last decade in most prominent research topics.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Benefits&lt;/strong&gt;&lt;br /&gt;
Maintain reputation of thought leadership in the area of cancer research, advance knowledge by submitting a paper into a proceedings journal based on the trends, come up with a repeatable, automated process, potentially &lt;strong&gt;reuse&lt;/strong&gt; the process as a service to meet the demand of understanding ongoing trends in technology.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Data Specification&lt;/strong&gt;&lt;br /&gt;
Data from prior conferences in .docx, .pdf, .xlsx, .csv will be provided to support the work.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Solution&lt;/strong&gt;&lt;br /&gt;
Visuals for the 5 objectives will be provided with appropriate resolution as .jpeg images. Code underlying all the data preparation and analysis will be provided, too.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;people&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;People&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;A project manager and a data scientist from Awesome Analytics.&lt;/li&gt;
&lt;li&gt;A cancer scientist from the client to guide the design and aesthetic features of the visuals.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;process&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Process&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Phases&lt;/strong&gt;&lt;br /&gt;
Emphasize, Define, Ideate, Prototype, Test, Implement&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Communication&lt;/strong&gt;&lt;br /&gt;
Weekly meetings will take place to collect feedback.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Security Classification&lt;/strong&gt;&lt;br /&gt;
Data is public.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;issues-ideas-and-principles&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Issues, Ideas and Principles&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Purpose&lt;/strong&gt;&lt;br /&gt;
Understanding of conference authors and research trends, not simple data summaries or prediction or technology. Maybe a technology - a program rerun each conference.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Confidentiality&lt;/strong&gt;&lt;br /&gt;
Transmission of public data does not pose much issue: email is a valid method. Things get more complicated with private or classified data.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Data Formats&lt;/strong&gt;&lt;br /&gt;
Text data can be stored on disk using many formats, each requiring its own parsing methods to convert text into a common representation.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Data Encoding&lt;/strong&gt;&lt;br /&gt;
Technical abstracts are submitted from around the world. Text in abstracts contains many special symbols and letters from other alphabets. These are handled by an expanded character set, called UTF-8, but may require special handling when cleaning text.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Data Collection&lt;/strong&gt;&lt;br /&gt;
Generated by humans with a non-standard process which creates much nuisance variation in data, say how names and countries are written down, that complicates data preparation.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Sources of variation&lt;/strong&gt;&lt;br /&gt;
Key idea in dealing with much data, including messy text, is to think of it in terms of variable components that combine together to make the observed data.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Automated Tools vs Manual Rules&lt;/strong&gt;&lt;br /&gt;
Data with nuisance variation breaks assumptions of automated tools and often requires creation of manually crafted rules, one by one, through trial and error. Regular expression and dictionaries are key technologies. This, of course, slows down work quite a bit.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Simple versus Complex Transformations&lt;/strong&gt;&lt;br /&gt;
The questions of author origins and cooperation can be obtained through straightforward manipulations of the provided data. However, finding novel variants of cancer, clustering abstracts by topic or trending research topics over time is not as clear-cut. The later set of problems requires statistical models to give us algorithms that can output probabilities, topics, and clusters.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;relevant-r-packages&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Relevant R packages&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Data&lt;/strong&gt;&lt;br /&gt;
state.abb, mapdata&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Import&lt;/strong&gt;&lt;br /&gt;
readxl, readr, pdftools&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Tidy&lt;/strong&gt;&lt;br /&gt;
tidytext, tidygraph&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Transform&lt;/strong&gt;&lt;br /&gt;
xml2, dplyr, stringr&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Visualize&lt;/strong&gt;&lt;br /&gt;
ggplot2, ggrepel&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Model&lt;/strong&gt;&lt;br /&gt;
topicmodels&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Communicate&lt;/strong&gt;&lt;br /&gt;
Rmarkdown&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;!-- BLOGDOWN-HEAD




/BLOGDOWN-HEAD --&gt;
</description>
    </item>
    
    <item>
      <title>Case Study 2</title>
      <link>/post/case2/</link>
      <pubDate>Mon, 22 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/case2/</guid>
      <description>&lt;!-- BLOGDOWN-BODY-BEFORE

/BLOGDOWN-BODY-BEFORE --&gt;

&lt;div id=&#34;conference-proceedings-analysis&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Conference Proceedings Analysis&lt;/h2&gt;
&lt;div id=&#34;project&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Project&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Background&lt;/strong&gt;&lt;br /&gt;
A retail company XYZ LLC prides itself on excellent customer service. One way to deliver excellence is by listening to customer complaints about their products and services collected through various channels like email or phone. Upon receiving a complaint, it is supposed to go through a classification process assigning it a product, sub-product and progressively detailed reasons for the complaint. The purpose of the classes is to organize complaints, and enable calculation of descriptive statistics and trending to get a better insight into what needs to be adjusted and how to prioritize work. However, being a large company with many and multifaceted products, the classification tree is deep and broad. During each complaint classification cycle, a complaint can pass through subtrees with options in the dozens which is a heavy cognitive load on the customer associate. The heavy load translates into slow downs, avoidance of work, missing data, poor data quality, a need for a quality assurance process, job dissatisfaction and increased turnover. All these negative side-effects undermine delivery of excellent customer service and impose extra costs.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Objectives&lt;/strong&gt;&lt;br /&gt;
The central task is to make the classification process much easier to reduce or eliminate its negative side-effects. Provide a wrapper around the code such that it can integrate into the existing user interface and improve the current classification process.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Benefits&lt;/strong&gt;&lt;br /&gt;
Making the classification process substantially easier will lead to&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Data Specification&lt;/strong&gt;&lt;br /&gt;
Few years of complaints data in .csv will be provided to support the work.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Solution&lt;/strong&gt;&lt;br /&gt;
Use the data generated by the complaint classification process to develop a predictive model that can take complaint text and predict class probabilities. Computed class probabilities can be used to sort the classes and only show the most likely batch. This will produce a dynamic classification process that will be sensitive to the information in the complaint and guide the customer associate towards the most fitting classes without completely removing them out of the process.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;people&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;People&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;A project manager, a data scientist and a developer from Awesome Analytics.&lt;/li&gt;
&lt;li&gt;An expert on the complaint data and the user interface, a customer associate, developers responsible for the user interface from XYZ.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;process&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Process&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Phases&lt;/strong&gt;&lt;br /&gt;
Emphasize, Define, Ideate, Prototype, Test, Implement&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Communication&lt;/strong&gt;&lt;br /&gt;
Weekly meetings will take place to collect feedback.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Security Classification&lt;/strong&gt;&lt;br /&gt;
Data is private.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;issues-ideas-and-principles&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Issues, Ideas and Principles&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Purpose&lt;/strong&gt;&lt;br /&gt;
A predictive model integrated into an interactive user interface rather than understanding or automated actions.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Confidentiality&lt;/strong&gt;&lt;br /&gt;
Complaint data has personally identifying as well as business sensitive information.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Data Transfer&lt;/strong&gt;&lt;br /&gt;
Private data requires a more serious consideration of data transfer. For example, working on site or placing a machine in client’s environment or establishing direct, encrypted transfer.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Data Management&lt;/strong&gt;&lt;br /&gt;
With confidential data you have to worry about access, provinence, and potentially destruction. A good access principle to follow is limitting access project materials only to those actually working the projects. Provinence involves recording the trail of the data as it moves around and is modified. Finally, data destruction upon project completion is a good, risk-averse practice.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Data Formats&lt;/strong&gt;&lt;br /&gt;
A .csv format is really typical, but can be generated in various ways as there is no commonly agreed upon specification. Commas and new line characters and double quotes can appear in text fields, and without properly quoting them, the separation of cells or lines can get lost.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Complex Transformations&lt;/strong&gt;&lt;br /&gt;
How to transform a piece of text into a class, especially when text is highly variable and there are hundreds of classes? No intuitive answer comes - the problem is complex, and manually constructed rules will do poorly and take enourmous time to develop. Data, however, contains many examples of what class was assigned to a piece of text. Statistical models can be used to represent a large number of possible relationship between text and class, and then data be used to find the relationship most consistent with data.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Assessment of Predictive Models&lt;/strong&gt;&lt;br /&gt;
We can split the data into two, one part for learning a relationship of text and class consistent with data, another for testing its accuracy. We could calculate overall accuracy as well as class specific accuracies.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Interpretability of Predictive Models&lt;/strong&gt;&lt;br /&gt;
Complex non-linear mathematical functions are learned to represent the relationship of text and class. What if someone wanted to know what pieces of information in the complaint contributed to it being classified in some way? Interpretability is an important aspect of understanding the learned model and providing reasons for the automated predictions.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Conditions of Application&lt;/strong&gt;&lt;br /&gt;
In this case, applying the predictive model to the whole classification tree is unnecessary and not possible from the beginning. In this project, the most impact can be achieved by considering subtrees that have more than 5 options, have sufficient data and can be handled accurately by the model.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Kinds and Gradations of Automation&lt;/strong&gt;&lt;br /&gt;
This is an example of outsourcing some mental work to a machine. If a task is repeatable and can be broken down into steps, then we can think of sharing those steps between a human and a machine, with the balance roughly giving you the amount of automation.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Improvement over Time&lt;/strong&gt; A system built on data can often improve with more data. In this case, predictive models will get more accurate, more parts of the classification tree can be reached systematically by a customer associate and generate data to build additional models. By putting some predictive models into a system sets a company on a trajectory of improvements.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;relevant-r-packages&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Relevant R packages&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Import&lt;/strong&gt;&lt;br /&gt;
readr&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Transform&lt;/strong&gt;&lt;br /&gt;
dplyr, stringr, text2vec&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Visualize&lt;/strong&gt;&lt;br /&gt;
ggplot2&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Model&lt;/strong&gt;&lt;br /&gt;
xgboost, lime&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Automate&lt;/strong&gt; R packaging system&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;!-- BLOGDOWN-HEAD




/BLOGDOWN-HEAD --&gt;
</description>
    </item>
    
    <item>
      <title>Introduction</title>
      <link>/post/intro/</link>
      <pubDate>Mon, 08 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/intro/</guid>
      <description>&lt;!-- BLOGDOWN-BODY-BEFORE

/BLOGDOWN-BODY-BEFORE --&gt;

&lt;div id=&#34;outline&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Outline&lt;/h2&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Introductions&lt;/li&gt;
&lt;li&gt;Analytics as a Layer of Digital Transformations&lt;/li&gt;
&lt;li&gt;Introduction to R&lt;/li&gt;
&lt;li&gt;Installation of RStudio&lt;/li&gt;
&lt;li&gt;Demo of Programming in RStudio&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div id=&#34;data-science-as-a-layer-of-digital-transformation&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Data Science as a Layer of Digital Transformation&lt;/h2&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;https://synikitin.github.io/analytics6600/img/digital.png&#34; /&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;cycles-of-innovation&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Cycles of Innovation&lt;/h2&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/3/33/Spiral_model_%28Boehm%2C_1988%29.png&#34; /&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;problem-driven-innovation&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Problem-Driven Innovation&lt;/h2&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;https://synikitin.github.io/analytics6600/img/design_circle.png&#34; /&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;analytics-producer&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Analytics Producer:&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Roles: Data scientists, software developers, infrastructure engineers, business analysts, subject matter experts&lt;/li&gt;
&lt;li&gt;Backgrounds: Math/stats, social sciences, economics, computer science&lt;/li&gt;
&lt;li&gt;Skills: Math/statistics, communications, domain expertise, “end-to-end”&lt;/li&gt;
&lt;li&gt;Key Attributes: Curiosity, a desire to learn, a willingness to get hands dirty&lt;/li&gt;
&lt;li&gt;Culture: Work in close proximity, exposure to variety of problems, safe to question, acceptable failure rate&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;analytics-client&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Analytics Client:&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Available data and an SME (can someone plug in a laptop and query the data?)&lt;/li&gt;
&lt;li&gt;Business lead (provides guidance, removes roadblocks, serves as sounding board)&lt;/li&gt;
&lt;li&gt;Quantifying the value to be created&lt;/li&gt;
&lt;li&gt;Understanding the existing workflow (flowcharts are your friend)&lt;/li&gt;
&lt;li&gt;Access to a real live user in the wild&lt;/li&gt;
&lt;li&gt;Well-defined scope, in writing&lt;/li&gt;
&lt;li&gt;Frequent communications with feedback (design sessions)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;data-science-cycle&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Data Science Cycle&lt;/h2&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;https://synikitin.github.io/analytics6600/img/data-science.png&#34; /&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;application-to-wait-time-prediction-project&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Application to Wait Time Prediction Project&lt;/h2&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;https://synikitin.github.io/analytics6600/img/waittime.png&#34; /&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;technical-ecosystem&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Technical Ecosystem&lt;/h2&gt;
&lt;p&gt;Overview of R and Rstudio ecosystem: &lt;a href=&#34;http://fg2re.sellorm.com&#34; class=&#34;uri&#34;&gt;http://fg2re.sellorm.com&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;


&lt;!-- BLOGDOWN-HEAD




/BLOGDOWN-HEAD --&gt;
</description>
    </item>
    
    <item>
      <title>Projects</title>
      <link>/post/guidelines/</link>
      <pubDate>Mon, 10 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/guidelines/</guid>
      <description>&lt;!-- BLOGDOWN-BODY-BEFORE

/BLOGDOWN-BODY-BEFORE --&gt;

&lt;div id=&#34;sections-and-rubric&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Sections and Rubric&lt;/h2&gt;
&lt;p&gt;You can get total of 60 points for the project. Here is the break down:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Document settings (1 point)&lt;/strong&gt;&lt;br /&gt;
Fix your upper functions. Put the bit of code below at the top of your Rmarkdown document (replace what’s there be default). Note the self_contained and code_folding options. Also, note the indentation, it is necessary for the options to take effect.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;title: &amp;quot;Project&amp;quot;
author: &amp;quot;Your Name&amp;quot;
date: &amp;quot;April 10, 2017&amp;quot;
output:  
  html_document:    
    self_contained: true   
    code_folding: hide   &lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Knitting (1 point)&lt;/strong&gt;&lt;br /&gt;
Make sure knitting works. Given data and your .Rmd, I should be able to knit a self-contained html with code folding without any errors. The .html file is what you will use for your presentation, so you must be able to knit your .Rmd file.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Context (5 points)&lt;/strong&gt;&lt;br /&gt;
Describe the domain or motivation behind the project. Why is it interesting or useful? Where does the data come from? What questions or problems, at a high level, you want to solve? This section needs to set expectations and tune the intuitions of readers before they see your analyses or function code. At least 5 sentences.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Data (5 points)&lt;/strong&gt;&lt;br /&gt;
Provide a thorough description of data. It should include source (with hyperlink if possible), format of file, number of data structures, dimensions, variable meanings (in groups if there are too many variables). Print out of a few rows of data. For example,&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;head(mtcars)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                    mpg cyl disp  hp drat    wt  qsec vs am gear carb
## Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4
## Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4
## Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1
## Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1
## Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2
## Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Data prep details (5 points)&lt;/strong&gt;&lt;br /&gt;
Discuss issues with the raw data. For example, problems with column names, data types, missing values, data being split among multiple file, or important variables being stored in column headers. Or maybe what you did to make the data nicer to work with.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Core (30 points)&lt;/strong&gt;&lt;br /&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Questions and Answers&lt;/strong&gt;&lt;br /&gt;
Separate your question-answer combinations into separate sections. State each question clearly. For each question, provide reasons for why you are calculating some number or making a chart to answer a specific question (why this and not something else). You should try to do a mixture of question-answers where you do calculations, like means, explore the full distribution of a variable, maybe with a histogram, and explore relationships among variables, using scatterplots and ggplot’s faceting to group data by a categorical variable. Provide a summary statement for each question describing which packages you used and for what functionality.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Functions&lt;/strong&gt;&lt;br /&gt;
Separate your functions into separate sections. Describe what the initial input is and what the final output is. Then describe the set of functions that you will write and what each does and how they fit together into a larger program that allows you to automate your task. For each function you code, provide high level logical version.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func &amp;lt;- function(x) {
  I create a container for outputs based on length of x
  I run a loop over columns of x
  Inside the loop I calculate a mean
  After the loop is done I return means for all columns
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Also, for each function, describe each input and output in terms of what R type of data and dimensions are expected, and what the overall purpose of the function is. You can place these in comments like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Purpose: This function does awesome stuff
# Input: x is a data frame of mixed types, but with more rows than columns
# Output: y is a double vector of summary statistics for each column
func &amp;lt;- function(x) {
  y &amp;lt;- something(x)
  return(y)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Provide a summary statement for each function describing which packages you used and for what functionality.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;7&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Tables and Charts (3 points)&lt;/strong&gt;&lt;br /&gt;
Make well-formated tables and charts. See a suggestion for tables below using &lt;code&gt;kable&lt;/code&gt; function from &lt;strong&gt;knitr&lt;/strong&gt; package. For charts, use &lt;strong&gt;ggplot2&lt;/strong&gt;. Make sure to fix title, axes labels, colors, legend and theme, if any. Remember that you can control every feature of the plot and make it look very nice. I only expect cleaned up displays, not professionally designed.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Organization (5 points)&lt;/strong&gt;&lt;br /&gt;
Text and code and its output should be in readable, formatted way. Look at the formatting guideliness below for pointers.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Presentation (5 points)&lt;/strong&gt;&lt;br /&gt;
Walk the class through your analysis or automation problem. Talk about the context, data quality and how you prepared it. Discuss what questions you had, how you approached answering them, and what the answer was. If you answered many, pick a couple that you find most interesting. Similarly, if you had an automation project, discuss what was the initial input and final output; walk through the sequence of functions that need to be used to get your from initial input to final output. Finally, mention what packages and maybe the crucial functions that were necessary to complete your project.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div id=&#34;formatting-guidelines&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Formatting Guidelines&lt;/h2&gt;
&lt;p&gt;The markdown file should be formatted in a readable form. Here are some rules I expect you apply:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;Make a special R chunk right after the setup chunk where you load all your packages.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Use headings for sections with &lt;code&gt;## Heading&lt;/code&gt; syntax. You control the size with the number of &lt;code&gt;#&lt;/code&gt;, where more is smaller:&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Break up your text with one return into blocks&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Statements here.
SPACE
Statements here.&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Separate your code into separate r-chunks that divide code into logical units, like importing and preparing data.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Surround r-chunks with one return on either side&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SPACE
&amp;#39;&amp;#39;&amp;#39;{r}
x &amp;lt;- 1:3
&amp;#39;&amp;#39;&amp;#39;
SPACE&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;You should make your code as readable as possible. Break lines after 80 characters (shown in the bottom left corner). Also, read over our book’s suggested style guide for other formatting issues &lt;a href=&#34;http://adv-r.had.co.nz/Style.html&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Use markdown formatting for lists if you need to enumerate something. For example,&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- line one
- line two
    1. line two.one
    2. line two.two&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Include external images with&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;![](url/or/disk/path/to/your/image)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Include urls with&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[word or phrase to hyperlink](url)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Make simple tables with package &lt;strong&gt;knitr&lt;/strong&gt; using function &lt;code&gt;kable&lt;/code&gt;, for example:&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;knitr::kable(head(mtcars))&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;mpg&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;cyl&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;disp&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;hp&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;drat&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;wt&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;qsec&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;vs&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;am&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;gear&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;carb&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;Mazda RX4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;21.0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;160&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;110&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.90&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2.620&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;16.46&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;Mazda RX4 Wag&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;21.0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;160&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;110&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.90&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2.875&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;17.02&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;Datsun 710&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;22.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;108&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;93&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.85&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2.320&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;18.61&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;Hornet 4 Drive&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;21.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;258&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;110&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.08&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.215&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;19.44&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;Hornet Sportabout&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;18.7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;360&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;175&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.15&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.440&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;17.02&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;Valiant&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;18.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;225&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;105&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2.76&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.460&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;20.22&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ol start=&#34;11&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;Format your charts to have nice axis labels and a title and any legends that are useful. Check out assignment 2 for some code examples. For example,&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggplot(aes(rating, ..prop..)) +
  geom_bar() +
  facet_grid(genre ~ occupation) +
  labs(x = &amp;quot;a&amp;quot;, y = &amp;quot;b&amp;quot;, title = &amp;quot;c&amp;quot;, caption = &amp;quot;Source: MovieLens&amp;quot;) +
  scale_x_continuous(breaks = 1:5) +
  theme(axis.text = element_text(size = 5),
    strip.text.x = element_text(size = 6),
    strip.text.y = element_text(size = 5, angle = 30))&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Additional markdown formatting syntax is &lt;a href=&#34;http://rmarkdown.rstudio.com/authoring_pandoc_markdown.html&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;


&lt;!-- BLOGDOWN-HEAD




/BLOGDOWN-HEAD --&gt;
</description>
    </item>
    
    <item>
      <title>Model</title>
      <link>/post/model/</link>
      <pubDate>Mon, 03 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/model/</guid>
      <description>&lt;!-- BLOGDOWN-BODY-BEFORE

/BLOGDOWN-BODY-BEFORE --&gt;

&lt;pre&gt;&lt;code&gt;## Warning: package &amp;#39;xgboost&amp;#39; was built under R version 3.3.2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Modeling of data patterns is a broad and deep topic that we can barely scratch in an intro class. We will concentrate on a couple types of models, aiming at prediction, on how to visualize models, and how to check predictive accuracy. The primary package we will use is &lt;strong&gt;xgboost&lt;/strong&gt;.&lt;/p&gt;
&lt;div id=&#34;predictive-task&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Predictive task&lt;/h2&gt;
&lt;p&gt;We consider a situation when we have a data frame of data, with &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; rows and &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; columns. We identify one column as a response variable and treat other variables as predictors. In addition, we distinguish between quantitative variables, for example, time or salary or rate of return, and categorical variables, like political affiliation or gender or loan approval status. The later distinction is necessary to make good choices about what type of R data is appropriate for different types of information. This may require some data preparation, but ultimately all information will be stored as &lt;strong&gt;double&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Given data and our choices about response / predictor variables, our task is to find a predictive function that takes values of predictors and returns a value close to the observed response variable. Here is how we formulate it mathematically.&lt;/p&gt;
&lt;p&gt;Lets consider a row &lt;span class=&#34;math inline&#34;&gt;\(i \in \{1, 2, \dots, n\}\)&lt;/span&gt; of a data frame, where one value is a response variable &lt;span class=&#34;math inline&#34;&gt;\(y_i \in \mathbb R\)&lt;/span&gt; and remaining values are predictors &lt;span class=&#34;math inline&#34;&gt;\(x_{i1}, x_{i2}, \dots, x_{ip-1} \in \mathbb R ^ {p-1}\)&lt;/span&gt;, hence accounting for the &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; columns. We assume&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;that &lt;span class=&#34;math inline&#34;&gt;\((y_i, x_{i1}, \dots, x_{ip-1})\)&lt;/span&gt; have been sampled independently from a probability distribution &lt;span class=&#34;math inline&#34;&gt;\(P(y, x_{1}, \dots, x_{p-1})\)&lt;/span&gt; that characterizes variation in each variable and dependencies among them, meaning data is representative,&lt;/li&gt;
&lt;li&gt;that there is a function &lt;span class=&#34;math inline&#34;&gt;\(g(x_{1}, \dots, x_{p-1})\)&lt;/span&gt; that provides a true description of how &lt;span class=&#34;math inline&#34;&gt;\(mean(y)\)&lt;/span&gt; dependends on predictors, meaning there is a dependency of response on predictors.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The first two assumptions are theoretical. To attempt to solve the problem, we also need practical assumptions that we are in control of and are primary components of what makes up a predictive model methodology:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;that we can define a set of possible models, &lt;span class=&#34;math inline&#34;&gt;\(\{f(x_{1}, \dots, x_{p-1}, \theta) : \theta \in \Theta\ \subset \mathbb R\}\)&lt;/span&gt;, such that there is at least one function in a set of possible functions that approximates the true relationship, &lt;span class=&#34;math inline&#34;&gt;\(f(x_{1}, \dots, x_{p-1}, \theta ^ *)\)&lt;/span&gt;, meaning we can find an adequate model of the true relationship&lt;/li&gt;
&lt;li&gt;that we can find a function to quantify overall predictive accuracy &lt;span class=&#34;math inline&#34;&gt;\(\sum_{i=1}^n L(y_i, f(x_{1}, \dots, x_{p-1}, \theta))\)&lt;/span&gt;, called a loss function, meaning we can quantify discrepancy between truth and approximation&lt;/li&gt;
&lt;li&gt;that we can obtain an estimation algorithm that searches through the possible values of &lt;span class=&#34;math inline&#34;&gt;\(\theta \in \Theta\)&lt;/span&gt;, which modifies how response variable and predictors are related, so that we can maximize overall predictive accuracy, meaning we can solve &lt;span class=&#34;math inline&#34;&gt;\(\mathrm{argmin}_{\theta \in \Theta}\ L(\theta)\)&lt;/span&gt; within computational, statistical, and organizational constraints&lt;/li&gt;
&lt;li&gt;that we can come up with an interpretable metric of accuracy to characterize our model, meaning we can summarise how well it does, compare it to other models and communicate it to someone else&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The above points are very general, and we need to specify some details to actually make this doable. First, we are going to use a set of functions and an estimation algorithm offered by package &lt;code&gt;xgboost&lt;/code&gt;, which iteratively builds step-wise functions, called trees, and combines them by averaging their outputs. We could consider other function sets like planes, quadratics, exponential curves, but all of these are very restrained and it becomes harder to manually put these together in a multivariate case, so we will just rely on a very general set of function from &lt;code&gt;xgboost&lt;/code&gt; that can approximate any of those and more.&lt;/p&gt;
&lt;p&gt;Secondly, we are going to use mean squared error to quantify mean predictive error of a model that predicts a quantitative response, defined as&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\sqrt{\frac{1}{n}\sum_{i = 1}^n(y_i - f(x_{1}, \dots, x_{p-1}, \theta))^2}\]&lt;/span&gt; and misclassification rate for a categorical response, defined as &lt;span class=&#34;math inline&#34;&gt;\(\frac{1}{n}\sum_{i = 1}^n \delta(y_i \neq f(x_{1}, \dots, x_{p-1}, \theta))\)&lt;/span&gt;, where &lt;span class=&#34;math inline&#34;&gt;\(\delta(condition)\)&lt;/span&gt; is 1 if true and 0 if false.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;examples&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Examples&lt;/h2&gt;
&lt;p&gt;To follow along run these commands:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;install.packages(&amp;quot;xgboost&amp;quot;)
library(xgboost)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lets look at some examples. &lt;strong&gt;mtcars&lt;/strong&gt; serves as a good example:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;head(mtcars)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                    mpg cyl disp  hp drat    wt  qsec vs am gear carb
## Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4
## Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4
## Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1
## Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1
## Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2
## Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;mpg&lt;/strong&gt;, miles per gallon, is a quantitative variable while &lt;strong&gt;am&lt;/strong&gt;, status of automatic transmission, is categorical. Suppose &lt;strong&gt;mpg&lt;/strong&gt; is the response variable &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt;, then our task is to estimate an unknown mathematical function &lt;span class=&#34;math inline&#34;&gt;\(g(x_{cyl}, x_{disp},...,x_{carb})\)&lt;/span&gt; that will take values of the other 10 variables in the table or similar values, and will output a predicted value of &lt;strong&gt;mpg&lt;/strong&gt; &lt;span class=&#34;math inline&#34;&gt;\(\hat y\)&lt;/span&gt; that is &lt;em&gt;close&lt;/em&gt; to the makes of cars we see in the table, but also close to new, unseen car makes, so &lt;span class=&#34;math inline&#34;&gt;\(\hat y \approx y\)&lt;/span&gt;. Outputs of &lt;span class=&#34;math inline&#34;&gt;\(f(\dots)\)&lt;/span&gt; will be quantitative, continuous, positive; this is called a regression model. If we are successful, then we can predict &lt;strong&gt;mpg&lt;/strong&gt; given values of the other variables.&lt;/p&gt;
&lt;p&gt;This expresses our choices about response and predictors:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;response &amp;lt;- &amp;quot;mpg&amp;quot;
preds &amp;lt;- setdiff(names(mtcars), response)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;xgboost&lt;/code&gt; has a special data structure &lt;code&gt;xgb.DMatrix&lt;/code&gt; to which we pass our variables:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;data &amp;lt;- xgb.DMatrix(data = as.matrix(mtcars[preds]), label = mtcars[[response]])&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next, we estimate a predictive model. First we need to specify what kind of predictive problem is it, regression or classification?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;params &amp;lt;- list(objective = &amp;quot;reg:linear&amp;quot;, max.depth = 2)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here &lt;code&gt;&amp;quot;reg:linear&amp;quot;&lt;/code&gt; means regression, so predicting a quantitative response variable. We will see other &lt;em&gt;objective&lt;/em&gt; settings when doing classification. Then we can run the estimation algorithm to obtain a candidate model:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;model &amp;lt;- xgboost(data, nrounds = 15, params = params)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1]  train-rmse:14.931315 
## [2]  train-rmse:10.956806 
## [3]  train-rmse:8.086657 
## [4]  train-rmse:6.014954 
## [5]  train-rmse:4.524509 
## [6]  train-rmse:3.452733 
## [7]  train-rmse:2.699348 
## [8]  train-rmse:2.160561 
## [9]  train-rmse:1.783578 
## [10] train-rmse:1.530202 
## [11] train-rmse:1.352114 
## [12] train-rmse:1.221488 
## [13] train-rmse:1.125132 
## [14] train-rmse:1.050767 
## [15] train-rmse:0.993811&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So, we have a model. How well does it do? This is a problem of diagnostics. We can use quantitative and visual methods to establish the predictive accuracy of our model. The important thing is to do model building and checking on different parts of a dataset, sometimes called train and test data. This way information for modeling and evaluating its accuracy is distinct. This is important for reducing or eliminating the bias that arises when you build a solution and then test it against the same data. Given that the solution is obtained by searching for a function that closely resembles patterns in the data, it should not be surprising if such a function shows high predictive accuracy - it was meant to.&lt;/p&gt;
&lt;p&gt;Luckily, &lt;code&gt;xgboost&lt;/code&gt; provides a special function to handle data partitions automatically. The technique is called &lt;strong&gt;cross-validation&lt;/strong&gt;. Data gets partitioned into non-overlapping subsets. A model is found for all but one subset and its accuracy is quantified against the held-out subset. This allows to control for bias in results. Then we repeat the same process by holding out a different dataset and estimating a model on the remaning. This is repeated until each dataset has served as a test dataset.&lt;/p&gt;
&lt;p&gt;Here is how you do it in &lt;code&gt;xgboost&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;model_check &amp;lt;- xgb.cv(data = data, nrounds = 15, params = params, 
                      nfold = 5, prediction = TRUE, verbose = FALSE)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## ##### xgb.cv 5-folds
##  iter train_rmse_mean train_rmse_std test_rmse_mean test_rmse_std
##     1      14.9878500     0.31380895      15.032428     1.3405395
##     2      11.0812408     0.20888959      11.157466     1.1113524
##     3       8.2421278     0.12427311       8.408589     0.8754797
##     4       6.1807056     0.07131542       6.455044     0.7856974
##     5       4.6787872     0.04965321       5.017423     0.7272057
##     6       3.5850778     0.05129103       3.997474     0.6469281
##     7       2.7906300     0.06210156       3.400866     0.6075206
##     8       2.2131812     0.06280777       3.001698     0.5637378
##     9       1.7991018     0.06750369       2.748674     0.5096921
##    10       1.5036920     0.07305091       2.595312     0.4707660
##    11       1.2832924     0.07423395       2.517527     0.3743411
##    12       1.1252114     0.07913846       2.466789     0.3799666
##    13       0.9963048     0.07112970       2.431705     0.3670777
##    14       0.9108604     0.07362564       2.404471     0.3923193
##    15       0.8446332     0.07651620       2.376313     0.4261411&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Output of &lt;code&gt;xgb.cv&lt;/code&gt; contains summary statistics on train and test data, and also predictions on the hold-out data. In addition to summary statistics, we can also do a few visualizations of the full pattern of predictive accuracy.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot.ts(as.data.frame(model_check$evaluation_log)[,c(2, 4)], plot.type = &amp;quot;single&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;#####../content/post/model_files/figure-html/unnamed-chunk-9-1.png&#34; width=&#34;672&#34; /&gt; The plot above shows mean predictive error in the model over training iterations. The gap between train and test shows the slight bias towards predicting train rather than test data. A good model should have both values low and not too far from each other.&lt;/p&gt;
&lt;p&gt;We can also examine residuals - observed minus predicted values - by plotting their histogram:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;hist(mtcars$mpg - model_check$pred)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;#####../content/post/model_files/figure-html/unnamed-chunk-10-1.png&#34; width=&#34;672&#34; /&gt; A good model should have this centered around 0.&lt;/p&gt;
&lt;p&gt;We can also check for a relationship between observed and predicted values. For a good model, these should be highly correlated:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot(mtcars$mpg, model_check$pred)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;#####../content/post/model_files/figure-html/unnamed-chunk-11-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;All the summary statistics and plots look pretty good. We can use the model we build to generate predictions, for old or new inputs. We would only need to convert data with the predictors into a &lt;code&gt;xgb.DMatrix&lt;/code&gt;. Here is an example using the predict function from base R on the full dataset:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;predict(model, data)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] 20.28938 20.28938 22.15593 20.14867 17.01779 18.76633 14.85491
##  [8] 23.08412 22.15593 18.94006 18.94006 16.05549 16.05549 16.05549
## [15] 10.59728 10.59728 14.73103 30.88917 30.01993 32.20821 22.15593
## [22] 16.50219 16.53521 14.69125 17.01779 28.23297 25.88072 28.94273
## [29] 15.72165 20.09435 14.69125 22.15593&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Similarly, if we used &lt;strong&gt;am&lt;/strong&gt; as the response variable, which is categorical, the task is also to find a predictive function, with the only difference from &lt;strong&gt;mpg&lt;/strong&gt; is that the output should be categorical, perhapse 1 for automatic and 0 manual, and no other possible values. By outputing only a few categorical values is the reason why such a predictive function is often called a classifier.&lt;/p&gt;
&lt;p&gt;We can use &lt;code&gt;xgboost&lt;/code&gt; to solve this problem, too. Lets first setup our variables and data.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;response &amp;lt;- &amp;quot;am&amp;quot;
preds &amp;lt;- setdiff(names(mtcars), response)

data &amp;lt;- xgb.DMatrix(data = as.matrix(mtcars[preds]), label = mtcars[[response]])&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The classification problem is different and requires a different way to capture a discrepancy between a candidate model and the underlying true function. Here we use &lt;code&gt;&amp;quot;binary:logistic&amp;quot;&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;params &amp;lt;- list(objective = &amp;quot;binary:logistic&amp;quot;, max.depth = 2)
model &amp;lt;- xgboost(data, nrounds = 15, params = params)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1]  train-error:0.093750 
## [2]  train-error:0.062500 
## [3]  train-error:0.031250 
## [4]  train-error:0.031250 
## [5]  train-error:0.031250 
## [6]  train-error:0.031250 
## [7]  train-error:0.031250 
## [8]  train-error:0.031250 
## [9]  train-error:0.031250 
## [10] train-error:0.031250 
## [11] train-error:0.000000 
## [12] train-error:0.031250 
## [13] train-error:0.000000 
## [14] train-error:0.031250 
## [15] train-error:0.031250&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Given our model, we once again ask how well it can do predict under new conditions.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;model_check &amp;lt;- xgb.cv(data = data, nrounds = 15, params = params, 
                      nfold = 5, prediction = TRUE, verbose = FALSE)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## ##### xgb.cv 5-folds
##  iter train_error_mean train_error_std test_error_mean test_error_std
##     1        0.0858976      0.02855265       0.2666668      0.2260777
##     2        0.0628206      0.02002597       0.2000000      0.1943650
##     3        0.0307696      0.01538480       0.2000000      0.1943650
##     4        0.0307696      0.01538480       0.2000000      0.1943650
##     5        0.0307696      0.01538480       0.1333334      0.1247218
##     6        0.0307696      0.01538480       0.1333334      0.1247218
##     7        0.0307696      0.01538480       0.1333334      0.1247218
##     8        0.0307696      0.01538480       0.1000000      0.1333333
##     9        0.0307696      0.01538480       0.1000000      0.1333333
##    10        0.0307696      0.01538480       0.1000000      0.1333333
##    11        0.0307696      0.01538480       0.1000000      0.1333333
##    12        0.0307696      0.01538480       0.1000000      0.1333333
##    13        0.0307696      0.01538480       0.1000000      0.1333333
##    14        0.0307696      0.01538480       0.1000000      0.1333333
##    15        0.0307696      0.01538480       0.1000000      0.1333333&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot.ts(as.data.frame(model_check$evaluation_log)[,c(2, 4)], plot.type = &amp;quot;single&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;#####../content/post/model_files/figure-html/unnamed-chunk-17-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;When dealing with a classification problem, instead of residuals, it is typicaly to see which classes a model gets well, and how often, using what is called a confusion matrix. Basically, we count how many correct and incorrect predictions are made and put them into a table. Note that predictions from the model are actually probabilities, and to get a class prediction we need to threshold a probability. It is typical to use .5.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;table(pred = as.integer(model_check$pred &amp;gt; .5), obs = mtcars$am)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     obs
## pred  0  1
##    0 18  2
##    1  1 11&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We the model can discriminate between automatic and manual pretty well, only confusing the two sometimes.&lt;/p&gt;
&lt;p&gt;This example showed a two-class prediction problem, but &lt;code&gt;xgboost&lt;/code&gt; can handle multi-class problem, too. We just need to adjust our parameters by setting objective argument by to &lt;code&gt;&amp;quot;multi:softmax&amp;quot;&lt;/code&gt; and &lt;code&gt;num_class&lt;/code&gt; to number of classes we are dealing with. Lastly, the classes should be represented with integers, starting from 0 and going to &lt;code&gt;num_class - 1&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;


&lt;!-- BLOGDOWN-HEAD




/BLOGDOWN-HEAD --&gt;
</description>
    </item>
    
    <item>
      <title>Program</title>
      <link>/post/program/</link>
      <pubDate>Mon, 06 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/program/</guid>
      <description>&lt;!-- BLOGDOWN-BODY-BEFORE

/BLOGDOWN-BODY-BEFORE --&gt;

&lt;div id=&#34;pipe&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Pipe&lt;/h2&gt;
&lt;p&gt;The purpose behind pipes is to help simplify code that contains a chain of function calls by avoiding saving intermediate results. Here is data prep as an example:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;All tidyverse packages load the pipe by default, but &lt;strong&gt;magrittr&lt;/strong&gt; is the official package that contains it, and other operators as well.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(magrittr)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Data example is based on the second assignment:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;u.data &amp;lt;- read_tsv(
  &amp;quot;u.data&amp;quot;,
  col_names = c(&amp;quot;user_id&amp;quot;, &amp;quot;movie_id&amp;quot;, &amp;quot;rating&amp;quot;, &amp;quot;timestamp&amp;quot;)
)
u.item &amp;lt;- read_delim(
  &amp;quot;u.item&amp;quot;,
  &amp;quot;|&amp;quot;,
  col_names = c(
&amp;quot;movie_id&amp;quot;, &amp;quot;movie_title&amp;quot;, &amp;quot;release_date&amp;quot;,
&amp;quot;video_release_date&amp;quot;, &amp;quot;IMDb_URL&amp;quot;, &amp;quot;unknown&amp;quot;,
&amp;quot;Action&amp;quot;, &amp;quot;Adventure&amp;quot;, &amp;quot;Animation&amp;quot;, &amp;quot;Children&amp;#39;s&amp;quot;,
&amp;quot;Comedy&amp;quot;, &amp;quot;Crime&amp;quot;, &amp;quot;Documentary&amp;quot;, &amp;quot;Drama&amp;quot;, &amp;quot;Fantasy&amp;quot;,
&amp;quot;Film-Noir&amp;quot;, &amp;quot;Horror&amp;quot;, &amp;quot;Musical&amp;quot;, &amp;quot;Mystery&amp;quot;, &amp;quot;Romance&amp;quot;,
&amp;quot;Sci-Fi&amp;quot;, &amp;quot;Thriller&amp;quot;, &amp;quot;War&amp;quot;, &amp;quot;Western&amp;quot;
)
  )
u.user &amp;lt;- read_delim(
  &amp;quot;u.user&amp;quot;,
  &amp;quot;|&amp;quot;,
  col_names = c(&amp;quot;user_id&amp;quot;, &amp;quot;age&amp;quot;, &amp;quot;gender&amp;quot;, &amp;quot;occupation&amp;quot;, &amp;quot;zip_code&amp;quot;)
)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Save each intermediate result&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;df1 &amp;lt;- inner_join(u.data, u.user, &amp;quot;user_id&amp;quot;)
df2 &amp;lt;- inner_join(df1, u.item, &amp;quot;movie_id&amp;quot;)
df3 &amp;lt;- mutate(df2,
timestamp = as_datetime(timestamp), 
release_date = dmy(release_date)
  ) 
df4 &amp;lt;- select(df3, -video_release_date)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Overwrite each result&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;df &amp;lt;- inner_join(u.data, u.user, &amp;quot;user_id&amp;quot;)
df &amp;lt;- inner_join(df, u.item, &amp;quot;movie_id&amp;quot;)
df &amp;lt;- mutate(df,
timestamp = as_datetime(timestamp), 
release_date = dmy(release_date)
  ) 
df &amp;lt;- select(df, -video_release_date)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Nest each result&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;df &amp;lt;- select(
  mutate(
inner_join(
  inner_join(
    u.data,
    u.user,
    &amp;quot;user_id&amp;quot;
  ),
  u.item,
  &amp;quot;movie_id&amp;quot;
),
timestamp = as_datetime(timestamp), 
release_date = dmy(release_date)
  ),
  -video_release_date
)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Pipe each result&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;df &amp;lt;- inner_join(u.data, u.user, &amp;quot;user_id&amp;quot;) %&amp;gt;% 
  inner_join(u.item, &amp;quot;movie_id&amp;quot;) %&amp;gt;% 
  mutate(
timestamp = as_datetime(timestamp), 
release_date = dmy(release_date)
  ) %&amp;gt;% 
  select(-video_release_date)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;Pipes rewrite your code as if you used pattern in 3., that is assigning results into the same name over and passing it forward. When you see pipes you should think that the left-handside is becoming the first argument in a function call:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;x %&amp;gt;% f()&lt;/code&gt; is &lt;code&gt;f(x)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x %&amp;gt;% f(y)&lt;/code&gt; is &lt;code&gt;f(x, y)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;10 %&amp;gt;% rnorm(mean = 5, sd = 1)&lt;/code&gt; is &lt;code&gt;rnorm(10, mean = 5, sd = 1)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Pipes are great for several function calls that operate on the same or maybe a couple datasets and result in a single output. Long chains of function calls should be broken up, and when you are dealing with many datasets or many outputs, these cannot be or should not be combined as it may actually lead to more confusing code. It will also not work out of the box or at all with some special functions (book has examples).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Additional operator allowing side-effects, like printing structure to check intermediate results, in the middle of transformations&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;df &amp;lt;- inner_join(u.data, u.user, &amp;quot;user_id&amp;quot;) %T&amp;gt;%
  str %&amp;gt;% 
  inner_join(u.item, &amp;quot;movie_id&amp;quot;) %T&amp;gt;% 
  str %&amp;gt;% 
  mutate(
timestamp = as_datetime(timestamp), 
release_date = dmy(release_date)
  ) %T&amp;gt;% 
  str %&amp;gt;% 
  select(-video_release_date)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div id=&#34;functions&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Functions&lt;/h2&gt;
&lt;p&gt;One value of functions is to capture repeatedly written and used blocks of code, potentially with varying arguments, to enable reuse and code simplification. It is also about extending R to do things it cannot do out of the box or with any package. Lastly, it is a good way to wrap your complicated code into larger logical units and make it better communicable.&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;A function is an object that has several components: name, arguments, body, return value, environment. Here is a generic example of creating a new function&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;name &amp;lt;- function(argument) {
  var &amp;lt;- code(argument)
  return(var)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The generic example does not do anything, but here is a simple working example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;test_miss &amp;lt;- function(column) {
  missingness &amp;lt;- is.na(column)
  test &amp;lt;- any(missingness)
  return(test)
}&lt;/code&gt;&lt;/pre&gt;
This example takes a column, checks for missing values and returns TRUE if there are any missing values and FALSE if there are no missing values. Here are its components:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;test_miss&lt;/code&gt; is the name&lt;/li&gt;
&lt;li&gt;&lt;code&gt;col&lt;/code&gt; is the argument&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{missingness &amp;lt;- is.na(col); test &amp;lt;- any(missingness)}&lt;/code&gt; is the body, or where your code goes&lt;/li&gt;
&lt;li&gt;return value is &lt;code&gt;test&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;environmment is global; this is where you have been creating your data objects and what you see in the &lt;em&gt;environment&lt;/em&gt; tab in Rstudio. Do not worry about this component too much as it is a more advanced feature of R.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Name functions as any other object. Avoid reserved names
&lt;ul&gt;
&lt;li&gt;Start with letters, but can also contain numbers, as well as underscores &lt;code&gt;_&lt;/code&gt; and points &lt;code&gt;.&lt;/code&gt; to separate letters. &lt;code&gt;sum_var&lt;/code&gt;, &lt;code&gt;sum.var&lt;/code&gt;, &lt;code&gt;sum1&lt;/code&gt; are all valid names. You can add special symbols by placing the name of your function into backsticks ``.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Arguments are also named. These can have default values.
&lt;ul&gt;
&lt;li&gt;Same naming conventions&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Arguments can have default values by setting an argument equal to some value:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mean_na &amp;lt;- function(var, na = TRUE) {
  x &amp;lt;- mean(var, na.rm = na)
  return(x)
}&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Body contains all the computations you want to perform repeatedly. This may be quite complex by adding conditional statements
&lt;ul&gt;
&lt;li&gt;The braces &lt;code&gt;{}&lt;/code&gt; contain all your code as if it was in a script or Rmarkdown chunk&lt;/li&gt;
&lt;li&gt;You can make your function do different things depending on some conditions&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;check_categories &amp;lt;- function(var) {
  if (is.character(var) || is.factor(var)) {
    return(TRUE)
  } else {
    return(FALSE)
  }
}

discretise &amp;lt;- function(var) {
  if (var &amp;lt; 0) {
    value &amp;lt;- &amp;quot;negative&amp;quot;
    return(value)
  } else if (var &amp;gt; 0) {
    value &amp;lt;- &amp;quot;positive&amp;quot;
    return(value)
  } else if (var == 0) {
    value &amp;lt;- &amp;quot;neutral&amp;quot;
    return(value)
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Return value may be required inside conditional statements, but otherwise is not needed because by default your funciton will return the last computed result in the body.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Environments are an advanced topic, but one thing that is important, is that functions can use variables not passed as arguments or created in the body, but rather created in the same place as the function. This is not recommended as it can make your functions unpredictable.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;Write all these functions and test them with example inputs:
&lt;ul&gt;
&lt;li&gt;Implement a function, with no arguments or code in the body&lt;/li&gt;
&lt;li&gt;Implement a function that has one argument and it just returns the argument value&lt;/li&gt;
&lt;li&gt;Implement a function that takes a vector of numbers and a single number to check whether a number is in the vector. It should return TRUE or FALSE&lt;/li&gt;
&lt;li&gt;Implement a function that takes a vector and a single value of the same type to find all missing values in a vector and replace them with a single value; use &lt;code&gt;if_else&lt;/code&gt; from &lt;em&gt;dplyr&lt;/em&gt; to help with this&lt;/li&gt;
&lt;li&gt;Implement a function that takes a vector and returns how many unique elements it has&lt;/li&gt;
&lt;li&gt;Implement a function that takes a vector and returns the shortest string if a vector is type character and smallest number if a vector is type double or integer. You can use function &lt;code&gt;which&lt;/code&gt; to find position of the minimum value, e.g. &lt;code&gt;which(3:1 == min(1:3))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Implement a function that calculates average squared difference between two vectors of numerical values&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div id=&#34;vectors&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Vectors&lt;/h2&gt;
&lt;p&gt;Data frames are a very useful data structure for data analysis, however when programming it may be an overkill or inadequate. This chapter introduces other ways of representing data in R. We concentrate on vectors - basic data structures in R out of which everything else is build, even data frames.&lt;/p&gt;
&lt;p&gt;Load &lt;code&gt;purrr&lt;/code&gt; library to get some of the functions.&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;Two basic types of vectors, atomic vectors that are usually just called vectors, and recursive vectors, usually called lists. There are two main differences: each element of an atomic vector has the same type and atomic vectors are flat, while recursive vectors can contain elements of different types and have hierarchical structure.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Vectors have types of logical, integer, double, complex, character, raw&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;c(TRUE, FALSE, NA)                 #logical
c(3L, 1L, 99L, NA)                 #integer
c(1.0, 0.008, NA, Inf, -Inf, NaN)  #double
c(1+4i, 44+1i, NA, Inf, -Inf, NaN) #complex
c(&amp;quot;hello&amp;quot;, &amp;quot;there&amp;quot;, NA)            #character
c(as.raw(0x00), as.raw(0xf4))      #raw&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;You can create vectors with the &lt;code&gt;c()&lt;/code&gt; function - which is mostly manual and shown above - or various functions that generate vectors with special values in them.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Logical vectors are typically created with logical comparisons or read from a file:&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;c(3L, 1L, 99L, NA) == 1L&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] FALSE  TRUE FALSE    NA&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;c(3L, 1L, 99L, NA) &amp;gt; 5L&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] FALSE FALSE  TRUE    NA&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Integer vectors are often read from a file, but are also used for subsetting other vectors, which requires pattern generation. If created by hand, numbers need &lt;em&gt;L&lt;/em&gt; as a suffix because the default numbers are double type:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;1&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;1L&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;1:3&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1 2 3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rep(1:3, times = 3)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1 2 3 1 2 3 1 2 3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rep(1:3, each = 3)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1 1 1 2 2 2 3 3 3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;seq(0, 12, by = 4)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1]  0  4  8 12&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;seq(0, 12, length.out = 3)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1]  0  6 12&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;seq_along(letters)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
## [24] 24 25 26&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;6&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Double vectors are often read from a file or may be generated with a random number generator:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rnorm(10, mean = 5, sd = 1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] 4.961494 4.891863 5.180934 5.142750 5.389000 5.990083 4.720025
##  [8] 5.037426 4.957679 6.044893&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;7&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;You will not see complex vectors unless you are doing pretty advanced math or physics.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Character vectors are often read from files, but also created, as you saw before with the Strings chapter:&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(stringr)
str_c(&amp;quot;file&amp;quot;, 1:10, &amp;quot;.csv&amp;quot;, sep = &amp;quot;&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;file1.csv&amp;quot;  &amp;quot;file2.csv&amp;quot;  &amp;quot;file3.csv&amp;quot;  &amp;quot;file4.csv&amp;quot;  &amp;quot;file5.csv&amp;quot; 
##  [6] &amp;quot;file6.csv&amp;quot;  &amp;quot;file7.csv&amp;quot;  &amp;quot;file8.csv&amp;quot;  &amp;quot;file9.csv&amp;quot;  &amp;quot;file10.csv&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;9&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;Raw vectors are also pretty rare and mostly used in more intricate programming.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Another way to create a vector is to coerce one into another.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;as.logical(c(0, 1, 1, 0))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] FALSE  TRUE  TRUE FALSE&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;as.integer(c(&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;3&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1 2 3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;as.double(c(&amp;quot;1.001&amp;quot;, &amp;quot;9.2842&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1.0010 9.2842&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;as.complex(c(&amp;quot;1.001&amp;quot;, &amp;quot;9.2842&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1.0010+0i 9.2842+0i&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;as.character(c(TRUE, FALSE))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;TRUE&amp;quot;  &amp;quot;FALSE&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;as.raw(0xf4)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] f4&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;10&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Coercision may be implicit by a function as a preparation for the downstream code&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;typeof(c(TRUE, 1L)) # these conversions follow the hierarchy from logical to character&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;integer&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;typeof(c(TRUE, 1))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;double&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;typeof(c(TRUE, &amp;quot;1&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;character&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sum(1:10 &amp;lt; 5)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 4&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;11&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;You can use &lt;code&gt;typeof&lt;/code&gt; or special test functions to determine types:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;is.logical(TRUE)
is.integer(1L)
is.double(1.0)
is.complex(1+1i)
is.character(&amp;quot;1&amp;quot;)
is.raw(as.raw(0x00))&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Another useful property of vectors is &lt;code&gt;length&lt;/code&gt;:&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x &amp;lt;- c(TRUE, FALSE, NA)
length(x)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 3&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;13&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Working with multiple vectors of different length will invoke recycling which is repeating the elements of the shorter vector to match the length of the longer vector:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;1:3 + 3 == 1:3 + c(3, 3, 3)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE TRUE TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;14&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;It may be useful to name vectors&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;c(a = 1, b = 2, c = 3)
setNames(1:3, c(&amp;quot;one&amp;quot;, &amp;quot;two&amp;quot;, &amp;quot;three&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## a b c 
## 1 2 3 
##   one   two three 
##     1     2     3&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;15&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;It is often needed to pull out specific elements of vectors. For this we use &lt;code&gt;[]&lt;/code&gt; syntax, with either position or name:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;c(1, 2, 3)[3]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;c(&amp;quot;one&amp;quot;, &amp;quot;two&amp;quot;, &amp;quot;three&amp;quot;)[2:3]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;two&amp;quot;   &amp;quot;three&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;c(&amp;quot;one&amp;quot;, &amp;quot;two&amp;quot;, &amp;quot;three&amp;quot;)[-1]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;two&amp;quot;   &amp;quot;three&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;c(&amp;quot;one&amp;quot;, &amp;quot;two&amp;quot;, &amp;quot;three&amp;quot;, &amp;quot;one&amp;quot;, &amp;quot;two&amp;quot;, &amp;quot;three&amp;quot;)[c(1, 3, 5)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;one&amp;quot;   &amp;quot;three&amp;quot; &amp;quot;two&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;c(1, 2, 3, 4)[-(2:3)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1 4&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;letters[TRUE]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;a&amp;quot; &amp;quot;b&amp;quot; &amp;quot;c&amp;quot; &amp;quot;d&amp;quot; &amp;quot;e&amp;quot; &amp;quot;f&amp;quot; &amp;quot;g&amp;quot; &amp;quot;h&amp;quot; &amp;quot;i&amp;quot; &amp;quot;j&amp;quot; &amp;quot;k&amp;quot; &amp;quot;l&amp;quot; &amp;quot;m&amp;quot; &amp;quot;n&amp;quot; &amp;quot;o&amp;quot; &amp;quot;p&amp;quot; &amp;quot;q&amp;quot;
## [18] &amp;quot;r&amp;quot; &amp;quot;s&amp;quot; &amp;quot;t&amp;quot; &amp;quot;u&amp;quot; &amp;quot;v&amp;quot; &amp;quot;w&amp;quot; &amp;quot;x&amp;quot; &amp;quot;y&amp;quot; &amp;quot;z&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;letters[c(TRUE, FALSE)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;a&amp;quot; &amp;quot;c&amp;quot; &amp;quot;e&amp;quot; &amp;quot;g&amp;quot; &amp;quot;i&amp;quot; &amp;quot;k&amp;quot; &amp;quot;m&amp;quot; &amp;quot;o&amp;quot; &amp;quot;q&amp;quot; &amp;quot;s&amp;quot; &amp;quot;u&amp;quot; &amp;quot;w&amp;quot; &amp;quot;y&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;1[0]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## numeric(0)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x &amp;lt;- c(one = 1, two = 2, three = 3)
x[c(&amp;quot;one&amp;quot;, &amp;quot;two&amp;quot;)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## one two 
##   1   2&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;16&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Lists share many features of atomic vectors, like naming, but are more complex than atomic vector because they can contain mixed types and hierarchies. To create a list you use&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;list(1, 2, 3)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [[1]]
## [1] 1
## 
## [[2]]
## [1] 2
## 
## [[3]]
## [1] 3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;list(TRUE, 1L, 1, 1+1i, &amp;quot;one&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [[1]]
## [1] TRUE
## 
## [[2]]
## [1] 1
## 
## [[3]]
## [1] 1
## 
## [[4]]
## [1] 1+1i
## 
## [[5]]
## [1] &amp;quot;one&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;list(one = 1, two = 2, three = 3)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $one
## [1] 1
## 
## $two
## [1] 2
## 
## $three
## [1] 3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;list(one = 1, two = list(three = 3, four = 4))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $one
## [1] 1
## 
## $two
## $two$three
## [1] 3
## 
## $two$four
## [1] 4&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str(list(one = 1, two = list(three = 3, four = 4)))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## List of 2
##  $ one: num 1
##  $ two:List of 2
##   ..$ three: num 3
##   ..$ four : num 4&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;17&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Lists also have the basic properties of vectors:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;typeof(list(1))
length(list(1, 2, 3, 4))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;list&amp;quot;
## [1] 4&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;18&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;You can also subset lists to pull various elements, either by position or name:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;list(1, 2, 3)[1:2]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [[1]]
## [1] 1
## 
## [[2]]
## [1] 2&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;list(1, 2, list(3, 4))[[3]]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [[1]]
## [1] 3
## 
## [[2]]
## [1] 4&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x &amp;lt;- list(one = 1, two = 2)
x[&amp;quot;one&amp;quot;]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $one
## [1] 1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x$one&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;19&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Vectors and lists can be enhanced with &lt;code&gt;attributes&lt;/code&gt;. The most important ones are &lt;em&gt;names&lt;/em&gt;, &lt;em&gt;dims&lt;/em&gt; and &lt;em&gt;class&lt;/em&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;attributes(mtcars) #to check
attr(mtcars, &amp;quot;something&amp;quot;) &amp;lt;- 1:3 #to set&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $names
##  [1] &amp;quot;mpg&amp;quot;  &amp;quot;cyl&amp;quot;  &amp;quot;disp&amp;quot; &amp;quot;hp&amp;quot;   &amp;quot;drat&amp;quot; &amp;quot;wt&amp;quot;   &amp;quot;qsec&amp;quot; &amp;quot;vs&amp;quot;   &amp;quot;am&amp;quot;   &amp;quot;gear&amp;quot;
## [11] &amp;quot;carb&amp;quot;
## 
## $row.names
##  [1] &amp;quot;Mazda RX4&amp;quot;           &amp;quot;Mazda RX4 Wag&amp;quot;       &amp;quot;Datsun 710&amp;quot;         
##  [4] &amp;quot;Hornet 4 Drive&amp;quot;      &amp;quot;Hornet Sportabout&amp;quot;   &amp;quot;Valiant&amp;quot;            
##  [7] &amp;quot;Duster 360&amp;quot;          &amp;quot;Merc 240D&amp;quot;           &amp;quot;Merc 230&amp;quot;           
## [10] &amp;quot;Merc 280&amp;quot;            &amp;quot;Merc 280C&amp;quot;           &amp;quot;Merc 450SE&amp;quot;         
## [13] &amp;quot;Merc 450SL&amp;quot;          &amp;quot;Merc 450SLC&amp;quot;         &amp;quot;Cadillac Fleetwood&amp;quot; 
## [16] &amp;quot;Lincoln Continental&amp;quot; &amp;quot;Chrysler Imperial&amp;quot;   &amp;quot;Fiat 128&amp;quot;           
## [19] &amp;quot;Honda Civic&amp;quot;         &amp;quot;Toyota Corolla&amp;quot;      &amp;quot;Toyota Corona&amp;quot;      
## [22] &amp;quot;Dodge Challenger&amp;quot;    &amp;quot;AMC Javelin&amp;quot;         &amp;quot;Camaro Z28&amp;quot;         
## [25] &amp;quot;Pontiac Firebird&amp;quot;    &amp;quot;Fiat X1-9&amp;quot;           &amp;quot;Porsche 914-2&amp;quot;      
## [28] &amp;quot;Lotus Europa&amp;quot;        &amp;quot;Ford Pantera L&amp;quot;      &amp;quot;Ferrari Dino&amp;quot;       
## [31] &amp;quot;Maserati Bora&amp;quot;       &amp;quot;Volvo 142E&amp;quot;         
## 
## $class
## [1] &amp;quot;data.frame&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;20&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Several data structures you have seen are actually build out of vectors and lists combined with special attributes:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;typeof(lubridate::as_date(Sys.time()))
attributes(lubridate::as_date(Sys.time()))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;double&amp;quot;
## $class
## [1] &amp;quot;Date&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;iteration&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Iteration&lt;/h2&gt;
&lt;p&gt;Recall that functions can extend functionality of R in novel directions, and also help you avoid duplication or rewriting of the same code. Another technique with managing duplication is iteration: doing the same operation on different inputs, be it single numbers stored in a vector, or columns of a data frame, or multiple data frames stored in a list.&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Consider a situation where you loaded multiple data sets into a list and you want to check their dimensions to determine where they can be combined into a single data frame.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;datasets &amp;lt;- list(
  data1 = mtcars,
  data2 = ToothGrowth,
  data3 = WorldPhones,
  data4 = anscombe
)
dim(datasets$data1)
dim(datasets$data2)
dim(datasets$data3)
dim(datasets$data4)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 32 11
## [1] 60  3
## [1] 7 7
## [1] 11  8&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This code is repetitive and requires multiple copy-paste combinations and is not efficient, is error-prone and its verbosity competes with the logic of the code.&lt;/p&gt;
&lt;ol start=&#34;2&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;To remove repetitiveness of known, finite length, we can use for loops:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;results &amp;lt;- vector(&amp;quot;integer&amp;quot;, 4)       # 1. output
for (i in seq_along(datasets)) {      # 2. sequence
  results[i] &amp;lt;- ncol(datasets[[i]])   # 3. body 
}
results&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 11  3  7  8&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;output: usually a vector or a list to store results. &lt;code&gt;results &amp;lt;- vector(&amp;quot;integer&amp;quot;, 4)&lt;/code&gt; uses &lt;code&gt;vector&lt;/code&gt; function that takes type of data and length of the vector to create.&lt;/li&gt;
&lt;li&gt;sequence: usually a vector or a list that holds varying inputs. &lt;code&gt;i in seq_along(df)&lt;/code&gt; says that &lt;code&gt;i&lt;/code&gt; will take values in a sequence of numbers going from 1 to the length of &lt;code&gt;datasets&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;p&gt;body: code that is called repetitively with varying inputs. &lt;code&gt;results[i] &amp;lt;- ncol(datasets[[i]])&lt;/code&gt; is the code that is executed with different values of i. &lt;code&gt;ncol&lt;/code&gt; determines the number of columns for each data set in &lt;code&gt;datasets&lt;/code&gt; and stores it inside &lt;code&gt;results&lt;/code&gt;. This translates to&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;results[1] &amp;lt;- ncol(datasets[[1]])
results[2] &amp;lt;- ncol(datasets[[2]])
results[3] &amp;lt;- ncol(datasets[[3]])
results[4] &amp;lt;- ncol(datasets[[4]])&lt;/code&gt;&lt;/pre&gt;
Do these examples. Think carefully about how each problem relates to components of the loop:&lt;/li&gt;
&lt;li&gt;Apply function &lt;code&gt;sd&lt;/code&gt;, which calculates a standard deviation, to each column of mtcars&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Determine type of each column in ToothGrowth data&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;The pattern you have seen so far is to loop over indices and create a new data object, however there are several useful variants on it:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Modifying an existing data object&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;normalize &amp;lt;- function(x) {
  x_norm &amp;lt;- (x - mean(x)) / sd(x)
  x_norm2 &amp;lt;- round(x_norm, 2)
  return(x_norm2)
}
mtcars2 &amp;lt;- mtcars
head(mtcars)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                    mpg cyl disp  hp drat    wt  qsec vs am gear carb
## Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4
## Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4
## Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1
## Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1
## Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2
## Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;for (i in seq_along(mtcars2)) {
  mtcars2[[i]] &amp;lt;- normalize(mtcars2[[i]])
}
head(mtcars2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                     mpg   cyl  disp    hp  drat    wt  qsec    vs    am
## Mazda RX4          0.15 -0.10 -0.57 -0.54  0.57 -0.61 -0.78 -0.87  1.19
## Mazda RX4 Wag      0.15 -0.10 -0.57 -0.54  0.57 -0.35 -0.46 -0.87  1.19
## Datsun 710         0.45 -1.22 -0.99 -0.78  0.47 -0.92  0.43  1.12  1.19
## Hornet 4 Drive     0.22 -0.10  0.22 -0.54 -0.97  0.00  0.89  1.12 -0.81
## Hornet Sportabout -0.23  1.01  1.04  0.41 -0.84  0.23 -0.46 -0.87 -0.81
## Valiant           -0.33 -0.10 -0.05 -0.61 -1.56  0.25  1.33  1.12 -0.81
##                    gear  carb
## Mazda RX4          0.42  0.74
## Mazda RX4 Wag      0.42  0.74
## Datsun 710         0.42 -1.12
## Hornet 4 Drive    -0.93 -1.12
## Hornet Sportabout -0.93 -0.50
## Valiant           -0.93 -1.12&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Looping over values or names instead of indices&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;image_names &amp;lt;- dir(pattern = &amp;quot;.jpg&amp;quot;)
image_data &amp;lt;- vector(&amp;quot;list&amp;quot;, 4)
par(mfrow = c(2, 2))

for (name in image_names) {
  img &amp;lt;- jpeg::readJPEG(name)
  plot(1, 1, xlim = c(1, 640), ylim = c(1, 480), axes = FALSE, xlab = NA, ylab = NA)
  rasterImage(img, 1, 1, 640, 480)
}&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;https://synikitin.github.io/analytics6600/img/iteration.png&#34; /&gt;

&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Handling outputs of unknown length&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;means &amp;lt;- c(0, 1, 2)
out &amp;lt;- vector(&amp;quot;list&amp;quot;, length(means))
for (i in seq_along(means)) {
  n &amp;lt;- sample(100, 1)
  out[[i]] &amp;lt;- rnorm(n, means[[i]])
}
out &amp;lt;- unlist(out)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Handling inputs of unknown length&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;while (condition) {
  body
}&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Loop exercises:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;input: vector of logical values body: checks for TRUE and saves the index in the output vector output: vector of integers representing positions of TRUE values&lt;/li&gt;
&lt;li&gt;Create a function that takes a data frame, loops through its columns, calculates mean of each column, and returns a vector of double numbers&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;


&lt;!-- BLOGDOWN-HEAD




/BLOGDOWN-HEAD --&gt;
</description>
    </item>
    
    <item>
      <title>Wrangle - Part II</title>
      <link>/post/wrangle2/</link>
      <pubDate>Mon, 20 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/wrangle2/</guid>
      <description>&lt;!-- BLOGDOWN-BODY-BEFORE

/BLOGDOWN-BODY-BEFORE --&gt;

&lt;div id=&#34;strings&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Strings&lt;/h2&gt;
&lt;p&gt;Package: &lt;code&gt;library(stringr)&lt;/code&gt;&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;Creation:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x &amp;lt;- &amp;quot;Richard Stallman doesn&amp;#39;t mind if you read his mail as long as you don&amp;#39;t delete it before he reads it. &amp;quot;
y &amp;lt;- &amp;#39;Richard Stallman met Chuck Norris once. Chuck tried a roundhouse, but Richard bashed him 
in the skull.&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Try creating this string&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;#39;Richard Stallman&amp;#39;s beard trimmings can cure cancer. Too bad he never shaves.&amp;#39;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Escaping quotes to have quotes inside quotes&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;#39;Richard Stallman\&amp;#39;s beard trimmings can cure cancer. Too bad he never shaves.&amp;#39;
&amp;quot;Richard Stallman gets \&amp;quot;9 bits\&amp;quot; to the byte.&amp;quot;  &lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Use &lt;code&gt;writeLines&lt;/code&gt; as opposed to &lt;code&gt;print&lt;/code&gt; to show the actual string&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;writeLines(&amp;quot;Richard Stallman gets \&amp;quot;9 bits\&amp;quot; to the byte.&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;Special strings signifying space:
&lt;ul&gt;
&lt;li&gt;“\n” newline&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;“\r” carriage return&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;“\t” tab&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Create a vector of strings:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;c(&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;d&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Number of characters (length):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;str_length(
 c(&amp;quot;Richard Stallman can solve the halting problem... in polynomial time.&amp;quot;, NA)
)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Combine strings:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;str_c(&amp;quot;hello&amp;quot;, c(&amp;quot;there&amp;quot;, &amp;quot;here&amp;quot;), sep = &amp;quot; &amp;quot;)
str_c(&amp;quot;hello&amp;quot;, c(&amp;quot;there&amp;quot;, &amp;quot;here&amp;quot;, &amp;quot;&amp;quot;), sep = &amp;quot; &amp;quot;, collapse = &amp;quot; &amp;quot;)
x &amp;lt;- &amp;quot;Class&amp;quot;
str_c(
  x,
  &amp;quot;is ...&amp;quot;,
  if (wday(Sys.time(), label = TRUE) == &amp;quot;Mon&amp;quot;) &amp;quot;on&amp;quot; else &amp;quot;off&amp;quot;,
  sep = &amp;quot; &amp;quot;
)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Sub-strings:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;str_sub(&amp;quot;Richard Stallman did not write GNU Emacs, he simply read the source code from /dev/null.&amp;quot;, start = 1, end = 7)
str_sub(&amp;quot;Richard Stallman did not write GNU Emacs, he simply read the source code from /dev/null.&amp;quot;, start = -6, end = -1)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;String case:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;str_to_lower(&amp;quot;LARGE LETTERS&amp;quot;)
str_to_upper(&amp;quot;SMALL LETTERS&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;String sort:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;str_sort(c(&amp;quot;Monday&amp;quot;, &amp;quot;Tuesday&amp;quot;, &amp;quot;Saturday&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Exercise: Fix the following strings if needed, lower their case, then combine them with newline character to show one quote per line, and finally get the length of the full string.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;#39;Richard Stallman doesn&amp;#39;t need sudo. I will make him a sandwich anyway.&amp;#39;
&amp;quot;Richard Stallman&amp;#39;s beard is made of parentheses.&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Regular expression:&lt;br /&gt;
I often refer to this &lt;a href=&#34;https://www.cheatography.com/davechild/cheat-sheets/regular-expressions/&#34;&gt;cheatsheet&lt;/a&gt; to remind myself of syntax. I will show only simple examples as it is better learned piece by piece as needed.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;a-b 0-9 Alpha-numerical characters&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x &amp;lt;- &amp;quot;zip code 60099&amp;quot;
str_extract(string = x, pattern = &amp;quot;zip code&amp;quot;)
str_detect(string = x, pattern = &amp;quot;60099&amp;quot;)
str_replace(string = x, pattern = &amp;quot;60099&amp;quot;, replacement = &amp;quot;60000&amp;quot;)
str_split(string = x, pattern = &amp;quot; &amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;!-) Special symbols may need escaping if they are regex syntax&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x &amp;lt;- &amp;quot;zip code @ (#60099)&amp;quot;
str_extract(string = x, pattern = &amp;quot;\\(&amp;quot;)
str_detect(string = x, pattern = &amp;quot;#&amp;quot;)
str_replace(string = x, pattern = &amp;quot;@&amp;quot;, replacement = &amp;quot;&amp;quot;)
str_split(string = x, pattern = &amp;quot; &amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;. One of any symbols&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x &amp;lt;- &amp;quot;zip code @ (#60099).&amp;quot;
str_extract(string = x, pattern = &amp;quot;z.p&amp;quot;)
str_detect(string = x, pattern = &amp;quot;co.e&amp;quot;)
str_replace_all(string = x, pattern = &amp;quot;\\.&amp;quot;, replacement = &amp;quot;!&amp;quot;)
str_split(string = x, pattern = &amp;quot;.&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;Special symbols
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;\\d&lt;/code&gt; digits 0 - 9&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\\s&lt;/code&gt; spaces like \n&lt;/li&gt;
&lt;li&gt;[a1@] any group of symbols&lt;/li&gt;
&lt;li&gt;&lt;p&gt;[^a1@] ^ makes it NOT this group of symbols&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x &amp;lt;- &amp;quot;zip code @ (#60099).\n&amp;quot;
str_replace_all(string = x, pattern = &amp;quot;\\s&amp;quot;, replacement = &amp;quot; &amp;quot;)
str_detect(string = x, pattern = &amp;quot;[@#]&amp;quot;)
str_extract_all(string = x, pattern = &amp;quot;[^@#()]&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Anchors
&lt;ul&gt;
&lt;li&gt;^ front&lt;/li&gt;
&lt;li&gt;&lt;p&gt;$ back&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x &amp;lt;- &amp;quot;truth is truth&amp;quot;
str_replace_all(string = x, pattern = &amp;quot;^truth&amp;quot;, replacement = &amp;quot;lie&amp;quot;)
str_replace_all(string = x, pattern = &amp;quot;truth$&amp;quot;, replacement = &amp;quot;lie&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;| is a logical OR operator for multiple patterns&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x &amp;lt;- &amp;quot;zip code @ (#60099).\n&amp;quot;
str_replace_all(string = x, pattern = &amp;quot;\\d|[@#()]&amp;quot;, replacement = &amp;quot;&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;Quantifiers
&lt;ul&gt;
&lt;li&gt;? (0 or 1 times)&lt;/li&gt;
&lt;li&gt;+ (1 or more)&lt;/li&gt;
&lt;li&gt;&lt;p&gt;* (0 or more)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x &amp;lt;- &amp;quot;groowthh&amp;quot;
str_extract_all(string = x, pattern = &amp;quot;o+&amp;quot;)
str_detect(string = x, pattern = &amp;quot;o+w?th*&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;categorical-data-with-factor-type&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Categorical Data with Factor Type&lt;/h2&gt;
&lt;p&gt;Package: &lt;code&gt;library(forcats)&lt;/code&gt;&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;Create factor to represent a categorical variable&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x &amp;lt;- c(&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;)
factor(x, levels = c(&amp;quot;b&amp;quot;, &amp;quot;a&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Control levels (categories)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;factor(c(&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;), levels = c(&amp;quot;b&amp;quot;, &amp;quot;a&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Reorder levels using a numerical variable&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(dplyr)
x &amp;lt;- tibble(f = factor(letters[1:4]),
        n = c(3, 1, 2, 4))
y &amp;lt;- mutate(x, f = fct_reorder(f, n, mean))&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div id=&#34;date-datetime-time&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Date, Datetime, Time&lt;/h2&gt;
&lt;p&gt;Package: &lt;code&gt;library(lubridate)&lt;/code&gt;&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;Timestamps to datetimes&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(lubridate)
timestamp &amp;lt;- Sys.time() # creates an example timestamp
timestamp # shows timestamp
as.integer(timestamp) # shows underlying representation of timestamp
x &amp;lt;- as.integer(timestamp) # convert timestamp to integer
as_datetime(x) # convert integer to timestamp&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Range of datetimes&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Sys.time() + 1:10
range(Sys.time() + 1:10)
min(Sys.time() + 1:10)
max(Sys.time() + 1:10)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Extract pieces like days, weeks, years, hours, seconds…&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x &amp;lt;- Sys.time()
year(x)
month(x)
month(x, label = TRUE)
wday(x)
wday(x, label = TRUE)
hour(x)
minute(x)
second(x)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Strings to dates&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ymd(&amp;quot;2017-02-20&amp;quot;)
dmy(&amp;quot;01-01-1910&amp;quot;)
ymd(&amp;quot;2017-Feb-20&amp;quot;)
dmy_hms(&amp;quot;01-01-1910 23:44:56&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;


&lt;!-- BLOGDOWN-HEAD




/BLOGDOWN-HEAD --&gt;
</description>
    </item>
    
    <item>
      <title>Wrangle - Part I</title>
      <link>/post/wrangle/</link>
      <pubDate>Mon, 13 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/wrangle/</guid>
      <description>&lt;!-- BLOGDOWN-BODY-BEFORE

/BLOGDOWN-BODY-BEFORE --&gt;

&lt;div id=&#34;basic-concepts&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Basic Concepts&lt;/h1&gt;
&lt;div id=&#34;material&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Material&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;tibble(x = 1:3)&lt;/code&gt; local in R&lt;/li&gt;
&lt;li&gt;&lt;code&gt;data()&lt;/code&gt; - local in R&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;%22/Users/snikitin/Documents/training/class/analytics6600/static/data/movies.csv%22&#34;&gt;&lt;/a&gt; - local on disc&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;%22https://synikitin.github.io/analytics6600/data/movies.csv%22&#34;&gt;&lt;/a&gt; - remote on disk, direct download&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;%22https://www.quandl.com/tools/api%22&#34;&gt;&lt;/a&gt; - remote on disc, api&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;machinery&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Machinery&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;computer&lt;/li&gt;
&lt;li&gt;integrated development environment (IDE)&lt;/li&gt;
&lt;li&gt;programming language&lt;/li&gt;
&lt;li&gt;file formats&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;product&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Product&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;data&lt;/li&gt;
&lt;li&gt;clean data&lt;/li&gt;
&lt;li&gt;visualization&lt;/li&gt;
&lt;li&gt;statistical model&lt;/li&gt;
&lt;li&gt;report&lt;/li&gt;
&lt;li&gt;web application&lt;/li&gt;
&lt;li&gt;optimized algorithm&lt;/li&gt;
&lt;li&gt;package&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;task&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Task&lt;/h1&gt;
&lt;div id=&#34;io&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;IO&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;library(readr)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;library(tibble)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;tidy&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Tidy&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;library(tidyr)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;transform&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Transform&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;library(dplyr)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;visualization&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Visualization&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;library(ggplot2)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;programming&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Programming&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;library(magrittr)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;learning-new-packages-and-functions&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Learning new packages and functions&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;CRAN&lt;/li&gt;
&lt;li&gt;&lt;code&gt;help(package = &amp;quot;readr&amp;quot;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;purpose&lt;/li&gt;
&lt;li&gt;available arguments&lt;/li&gt;
&lt;li&gt;example code, sometimes &lt;code&gt;demo(package = &amp;quot;stats&amp;quot;)&lt;/code&gt;, &lt;code&gt;example(&amp;quot;summarise&amp;quot;, package = &amp;quot;dplyr&amp;quot;)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;tibbles&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Tibbles&lt;/h1&gt;
&lt;div id=&#34;creating&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Creating&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;tibble&lt;/code&gt; tibble( population = c(783744, 923972, 823972, 789374), city = c(“chicago”, “columbus”, “boston”, “cleveland”) )&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;tribble&lt;/code&gt; tribble( ~x, ~y, 1, “2”, 3, 4 )&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;printing&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Printing&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;print(df, n, width)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;str&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;View&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;subsetting&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Subsetting&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;df[[&amp;quot;a&amp;quot;]]&lt;/code&gt;, &lt;code&gt;df[[1]]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;df$a&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;data-import&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Data Import&lt;/h1&gt;
&lt;div id=&#34;read_csv&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;read_csv&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;read_csv( 
  &amp;quot;Some random text here
  a,b,c
  1,2,! #This is a comment. ! is a missing value.
  4,5,6&amp;quot;,
  skip = 2,
  na = &amp;quot;!&amp;quot;,
  comment = &amp;quot;#&amp;quot;,
  n_max = 2,
  col_names = c(&amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;, &amp;quot;z&amp;quot;),
  col_types = cols(x = col_integer(),
                   y = col_double(),
                   z = col_character())
)             &lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;arguments&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;arguments&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;skip&lt;/li&gt;
&lt;li&gt;comment&lt;/li&gt;
&lt;li&gt;col_names&lt;/li&gt;
&lt;li&gt;na&lt;/li&gt;
&lt;li&gt;n_max&lt;/li&gt;
&lt;li&gt;locale&lt;/li&gt;
&lt;li&gt;col_types (logical, numbers, text, date, time, datetime)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;write_csv-write_excel_csv-write_rds&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;write_csv, write_excel_csv, write_rds&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;similar arguments&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;other-packages&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;other packages&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;haven&lt;/li&gt;
&lt;li&gt;readxl&lt;/li&gt;
&lt;li&gt;DBI&lt;/li&gt;
&lt;li&gt;jsonlite&lt;/li&gt;
&lt;li&gt;&lt;p&gt;xml2&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Lets practice &lt;code&gt;read_csv&lt;/code&gt; with the following data:&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;x &amp;lt;- &amp;quot;Confidential Data - Email abc@gmail.com for Permission
    $earnings,Months in 2017,store
    14343.43,January,! *Note: missing values marked with !
    34322.33,February,6343\n&amp;quot;
    
writeChar(  
  x,
  &amp;quot;readr_example.csv&amp;quot;,
  176
)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;tidying-data&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Tidying Data&lt;/h1&gt;
&lt;div id=&#34;structure&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Structure&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;columns&lt;/li&gt;
&lt;li&gt;rows&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;semantics&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Semantics&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;unit&lt;/li&gt;
&lt;li&gt;variable&lt;/li&gt;
&lt;li&gt;value&lt;/li&gt;
&lt;li&gt;observation&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;messy-data&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Messy data&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Column headers are values, not variable names. This is messy&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;a &amp;lt;- tribble(
  ~region, ~`$0 - $100k`, ~`$100k - $1,000k`, ~`$1,000k - $10,000k`,
  &amp;quot;midwest&amp;quot;, 152, 78, 5,
  &amp;quot;west&amp;quot;, 190, 130, 10
  )
a&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 2 × 4
##    region `$0 - $100k` `$100k - $1,000k` `$1,000k - $10,000k`
##     &amp;lt;chr&amp;gt;        &amp;lt;dbl&amp;gt;             &amp;lt;dbl&amp;gt;                &amp;lt;dbl&amp;gt;
## 1 midwest          152                78                    5
## 2    west          190               130                   10&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and this is tidy by turning headers into a variable.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;gather(data = a, key = income, value = count, 2:4)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 × 3
##    region             income count
##     &amp;lt;chr&amp;gt;              &amp;lt;chr&amp;gt; &amp;lt;dbl&amp;gt;
## 1 midwest         $0 - $100k   152
## 2    west         $0 - $100k   190
## 3 midwest    $100k - $1,000k    78
## 4    west    $100k - $1,000k   130
## 5 midwest $1,000k - $10,000k     5
## 6    west $1,000k - $10,000k    10&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Multiple variables are stored in one column. This is messy&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;b &amp;lt;- tribble(
  ~`region-income`, ~count,
  &amp;quot;midwest, $0 - 100k&amp;quot;, 152,
  &amp;quot;west, $0 - 100k&amp;quot;, 190,
  &amp;quot;midwest, $100k - 1,000k&amp;quot;, 78,
  &amp;quot;west, $100k - 1,000k&amp;quot;, 130
)
b&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 4 × 2
##           `region-income` count
##                     &amp;lt;chr&amp;gt; &amp;lt;dbl&amp;gt;
## 1      midwest, $0 - 100k   152
## 2         west, $0 - 100k   190
## 3 midwest, $100k - 1,000k    78
## 4    west, $100k - 1,000k   130&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and this is tidy by splitting a variable into two variables.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;separate(data = b, col = `region-income`,
         into = c(&amp;quot;region&amp;quot;, &amp;quot;income&amp;quot;), sep = &amp;quot;, &amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 4 × 3
##    region         income count
## *   &amp;lt;chr&amp;gt;          &amp;lt;chr&amp;gt; &amp;lt;dbl&amp;gt;
## 1 midwest      $0 - 100k   152
## 2    west      $0 - 100k   190
## 3 midwest $100k - 1,000k    78
## 4    west $100k - 1,000k   130&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Variables are stored in rows. This is messy&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;d &amp;lt;- tribble(
  ~region, ~income, ~statistic,
  &amp;quot;midwest&amp;quot;, 193478374, &amp;quot;annual_max&amp;quot;,
  &amp;quot;midwest&amp;quot;, 878743, &amp;quot;annual_min&amp;quot;,
  &amp;quot;west&amp;quot;, 29743443, &amp;quot;annual_max&amp;quot;,
  &amp;quot;west&amp;quot;, 19984028, &amp;quot;annual_min&amp;quot;
)
d&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 4 × 3
##    region    income  statistic
##     &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt;      &amp;lt;chr&amp;gt;
## 1 midwest 193478374 annual_max
## 2 midwest    878743 annual_min
## 3    west  29743443 annual_max
## 4    west  19984028 annual_min&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and this is tidy by turning a variable into column headers.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;spread(data = d, key = statistic, value = income)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 2 × 3
##    region annual_max annual_min
## *   &amp;lt;chr&amp;gt;      &amp;lt;dbl&amp;gt;      &amp;lt;dbl&amp;gt;
## 1 midwest  193478374     878743
## 2    west   29743443   19984028&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Multiple types of observational units are stored in the same table, in this case two separate time scales. This is messy&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;e &amp;lt;- tribble(
  ~region, ~annual_max, ~annual_min, ~monthly_avg, ~month,
  &amp;quot;midwest&amp;quot;, 193478374, 878743, 193947931, &amp;quot;January&amp;quot;,
  &amp;quot;midwest&amp;quot;, 193478374, 878743, 153394881, &amp;quot;February&amp;quot;
)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and this is tidy by removing annual scale variables&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;select(e, -annual_max, -annual_min)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 2 × 3
##    region monthly_avg    month
##     &amp;lt;chr&amp;gt;       &amp;lt;dbl&amp;gt;    &amp;lt;chr&amp;gt;
## 1 midwest   193947931  January
## 2 midwest   153394881 February&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or this is tidy by removing monthly scale variables.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;select(e, -monthly_avg, -month) %&amp;gt;% 
  distinct&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1 × 3
##    region annual_max annual_min
##     &amp;lt;chr&amp;gt;      &amp;lt;dbl&amp;gt;      &amp;lt;dbl&amp;gt;
## 1 midwest  193478374     878743&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;A single observational unit is stored in multiple tables. This is messy&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;f &amp;lt;- tribble(
  ~region, ~income, ~statistic,
  &amp;quot;midwest&amp;quot;, 193478374, &amp;quot;annual_max&amp;quot;,
  &amp;quot;midwest&amp;quot;, 878743, &amp;quot;annual_min&amp;quot;
)
g &amp;lt;- tribble(
  ~region, ~income, ~statistic,
  &amp;quot;west&amp;quot;, 29743443, &amp;quot;annual_max&amp;quot;,
  &amp;quot;west&amp;quot;, 19984028, &amp;quot;annual_min&amp;quot;
)
f&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 2 × 3
##    region    income  statistic
##     &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt;      &amp;lt;chr&amp;gt;
## 1 midwest 193478374 annual_max
## 2 midwest    878743 annual_min&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;g&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 2 × 3
##   region   income  statistic
##    &amp;lt;chr&amp;gt;    &amp;lt;dbl&amp;gt;      &amp;lt;chr&amp;gt;
## 1   west 29743443 annual_max
## 2   west 19984028 annual_min&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and this is tidy by combining them into a single data frame.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;bind_rows(f, g)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 4 × 3
##    region    income  statistic
##     &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt;      &amp;lt;chr&amp;gt;
## 1 midwest 193478374 annual_max
## 2 midwest    878743 annual_min
## 3    west  29743443 annual_max
## 4    west  19984028 annual_min&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Tidy the following dataset. It consists of a history of quarterly earnings per share of Johnson and Johnson.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;df &amp;lt;- matrix(JohnsonJohnson, byrow = TRUE, ncol = 4) %&amp;gt;% 
  as_tibble() %&amp;gt;%
  rename(quarter1 = V1, quarter2 = V2, quarter3 = V3, quarter4 = V4) %&amp;gt;% 
  mutate(year = 1960:1980, stockinfo = &amp;quot;JNJ-NYSE&amp;quot;)
df&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 21 × 6
##    quarter1 quarter2 quarter3 quarter4  year stockinfo
##       &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt;     &amp;lt;chr&amp;gt;
## 1      0.71     0.63     0.85     0.44  1960  JNJ-NYSE
## 2      0.61     0.69     0.92     0.55  1961  JNJ-NYSE
## 3      0.72     0.77     0.92     0.60  1962  JNJ-NYSE
## 4      0.83     0.80     1.00     0.77  1963  JNJ-NYSE
## 5      0.92     1.00     1.24     1.00  1964  JNJ-NYSE
## 6      1.16     1.30     1.45     1.25  1965  JNJ-NYSE
## 7      1.26     1.38     1.86     1.56  1966  JNJ-NYSE
## 8      1.53     1.59     1.83     1.86  1967  JNJ-NYSE
## 9      1.53     2.07     2.34     2.25  1968  JNJ-NYSE
## 10     2.16     2.43     2.70     2.25  1969  JNJ-NYSE
## # ... with 11 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;relational-data&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Relational data&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;tables and keys (primary, foreign, surrogate); key in the following data sets&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;stocks &amp;lt;- tibble(earnings = c(800, 150, 240, 65),
                 volume = c(1599500, 30531626, 4276880, 25187460),
                 symbol = c(&amp;quot;GOOG&amp;quot;, &amp;quot;APPL&amp;quot;, &amp;quot;GS&amp;quot;, &amp;quot;MSFT&amp;quot;))
stocks&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 4 × 3
##   earnings   volume symbol
##      &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;  &amp;lt;chr&amp;gt;
## 1      800  1599500   GOOG
## 2      150 30531626   APPL
## 3      240  4276880     GS
## 4       65 25187460   MSFT&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;stocks2 &amp;lt;- tibble(earnings = c(800, 15),
                  volume = c(1599500, 13210000),
                  symbol = c(&amp;quot;GOOG&amp;quot;, &amp;quot;HBAN&amp;quot;))

symbols &amp;lt;- tibble(symbol = c(&amp;quot;GOOG&amp;quot;, &amp;quot;APPL&amp;quot;, &amp;quot;GS&amp;quot;, &amp;quot;HBAN&amp;quot;),
                  exchange = c(&amp;quot;NASDAQ&amp;quot;, &amp;quot;NASDAQ&amp;quot;, &amp;quot;NYSE&amp;quot;, &amp;quot;NASDAQ&amp;quot;))
symbols&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 4 × 2
##   symbol exchange
##    &amp;lt;chr&amp;gt;    &amp;lt;chr&amp;gt;
## 1   GOOG   NASDAQ
## 2   APPL   NASDAQ
## 3     GS     NYSE
## 4   HBAN   NASDAQ&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;left, right, outer join (mutating)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;inner_join(x = stocks, y = symbols, by = &amp;quot;symbol&amp;quot;)
left_join(x = stocks, y = symbols, by = &amp;quot;symbol&amp;quot;)
right_join(x = stocks, y = symbols, by = &amp;quot;symbol&amp;quot;)
full_join(x = stocks, y = symbols, by = &amp;quot;symbol&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;semi, anti join (filtering)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;semi_join(x = stocks, y = symbols, by = &amp;quot;symbol&amp;quot;)
anti_join(x = stocks, y = symbols, by = &amp;quot;symbol&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;intersect, union, setdiff&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;union(x = stocks, y = stocks2)
intersect(x = stocks, y = stocks2)
setdiff(x = stocks, y = stocks2)
setdiff(x = stocks2, y = stocks)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Identify primary and foreign keys in all datasets&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;set.seed(349834)

calls &amp;lt;- tibble(
  company = &amp;quot;schevchenko steele&amp;quot;, #rep(companies, each = 12)
  number = rbinom(5, 30, .3),
  month = month.name[1:5] #rep(month.name, 10)
)
sales &amp;lt;- tibble(
  company = &amp;quot;schevchenko steele&amp;quot;,
  amount = rgamma(10, 1e4, 1 / 1e4),
  month = month.name[-c(1, 9)]
)
orders &amp;lt;- tibble(
  company = &amp;quot;schevchenko steele&amp;quot;,
  fullfilment = rbeta(10, 4, 8),
  month = month.name[-c(1, 9)]
) &lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Join calls and sales for only matching months&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Enrich calls with whatever sales data there is&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Enrich sales with whatever calls data there is&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Join calls and sales for all months&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Obtain sales data for which you have calls&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Obtain orders data for which you have no calls&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Join all datasets into a single data frame with all months&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;


&lt;!-- BLOGDOWN-HEAD




/BLOGDOWN-HEAD --&gt;
</description>
    </item>
    
  </channel>
</rss>
